# coding=utf-8
"""
D. Оля и граф
ограничение по времени на тест:2 секунды
ограничение по памяти на тест:256 мегабайт
ввод:standard input
вывод:standard output

У Оли есть ориентированный невзвешенный граф, состоящий из n вершин и m ребер. Будем считать, что вершины графа пронумерованы от 1 до n некоторым способом. Тогда для каждого ребра графа, идущего от вершины v к вершине u, выполняется неравенство: v < u.

Теперь Оле интересно, сколько существует способов добавить в граф произвольное (возможно нулевое) количество ребер так, чтобы для полученного графа были выполнены условия:

 Из любой вершины с номером i (i < n) достижимы вершины с номерами i + 1, i + 2, ..., n.
 Для каждого ребра графа, идущего от вершины v к вершине u, выполняется неравенство: v < u.
 Между любыми двумя вершинами существует не более одного ребра.
 Кратчайшее расстояние между парой вершин i, j (i < j), для которых верно, что j - i ≤ k, равно j - i ребер.
 Кратчайшее расстояние между парой вершин i, j (i < j), для которых верно, что j - i > k, равно либо j - i, либо j - i - k ребер.


Два способа будем считать различными, если будет существовать пара вершин i, j (i < j) такая, что в первом полученном графе будет существовать ребро из i в j, а во втором — нет.

Помогите Оле. Так как искомое количество способов может быть достаточно большим, выведите его остаток от деления на 1000000007 (109 + 7).
Входные данные

В первой строке записаны три целых числа через пробел n, m, k (2 ≤ n ≤ 106, 0 ≤ m ≤ 105, 1 ≤ k ≤ 106).

Во последующих m строках записано описание ребер изначального графа. В i-ой строке записана пара целых чисел через пробел ui, vi (1 ≤ ui < vi ≤ n) — номера вершин, между которыми есть ориентированное ребро из ui в vi.

Гарантируется, что между любой парой вершин ui, vi существует не более одного ребра. Также гарантируется, что ребра графа записаны в порядке неубывания величин ui. Если из вершины ui имеется несколько ребер, то гарантируется, что эти ребра заданы в порядке возрастания величин vi.
Выходные данные

Выведите единственное целое число — ответ на задачу по модулю 1000000007 (109 + 7).
"""
from sys import stdin

N = 10 ** 6
MOD = 10**9 + 7


def task():
    n, m, k = map(int, stdin.readline().split())
    Sum = [0] * (N + 1)
    Power = [0] * (N + 1)
    for i in xrange(m):
        u, v = map(int, stdin.readline().split())
        if v - u == k + 1:
            Sum[u - 1] = 1
        elif v - u != 1:
            print 0
            quit()

    for i in xrange(n - 1, -1, -1):
        Sum[i] += Sum[i + 1]

    Power[0] = 1
    for i in xrange(1, N + 1):
        Power[i] = (Power[i - 1] * 2) % MOD

    answer = 0
    if not Sum[0]:
        answer += 1

    for i in xrange(n - k - 1):
        if Sum[0] != Sum[i]:
            continue
        if Sum[i + k + 1] > 0:
            continue
        answer += Power[min(n - k - 2, i + k) - i - (Sum[i + 1] - Sum[i + k + 1])]
        answer %= MOD

    print answer


task()
