# coding=utf-8
"""
E. Копирование данных
ограничение по времени на тест:2 секунды
ограничение по памяти на тест:256 мегабайт
ввод:standard input
вывод:standard output

Очень часто приходится копировать большие объемы данных. Такая операция может потребовать больших затрат компьютерных
ресурсов. В связи с этим, в этой задаче вам предлагается придумать способ быстрого копирования некоторой части одного
массива чисел в другой.

Более формально, вам задано два массива целых чисел a1, a2, ..., an и b1, b2, ..., bn длины n. Также есть m запросов двух
типов:

 Скопировать подотрезок массива a длины k, начиная с позиции x, в массив b, начиная с позиции y, то есть выполнить
 by + q = ax + q для всех целых q (0 ≤ q < k). Операция задана корректно — оба подотрезка целиком содержатся в массивах
 a и b соответственно.
 Определить значение в позиции x массива b, то есть найти значение bx.


Для каждого запроса второго типа выведите результат — значение соответствующего элемента массива b.
Входные данные

В первой строке через пробел заданы два целых числа n и m (1 ≤ n, m ≤ 105) — количество элементов в массивах и количество
запросов соответственно. Во второй строке задан массив целых чисел a1, a2, ..., an (|ai| ≤ 109). В третьей строке задан
массив целых чисел b1, b2, ..., bn (|bi| ≤ 109).

В следующих m строках заданы описания запросов. В i-ой строке сначала задано целое число ti — тип i-го
запроса (1 ≤ ti ≤ 2). Если ti = 1, то i-ый запрос обозначает операцию копирования, если ti = 2, то i-ый запрос обозначает
взятие значения в массиве b. Если ti = 1, то после типа запроса записаны три целых числа xi, yi, ki (1 ≤ xi, yi, ki ≤ n) —
параметры запроса копирования. Если ti = 2, то следом, после типа запроса, в строке записано целое число xi (1 ≤ xi ≤ n) —
позиция в массиве b.

Все числа в строках разделены одиночными пробелами. Гарантируется, что все запросы корректны, то есть границы
копирования не выходят за границы массивов a и b.
Выходные данные

Для каждого запроса второго типа в отдельную строку выведите результат.
"""
from sys import stdin

MED_L = 1 << 17
MAX_L = MED_L << 1


def task():
    n, m = map(int, stdin.readline().split())
    a = map(int, stdin.readline().split())
    b = map(int, stdin.readline().split())
    values = [map(int, i) for i in map(str.split, stdin.readlines())]

    x = [0] * m
    y = [0] * m
    z = [0] * m
    t = [-1] * MAX_L

    def mark(q, lo, hi):
        lo += MED_L
        hi += MED_L
        while lo <= hi:
            if lo & 1:
                t[lo] = q
                lo += 1
            if not (hi & 1):
                t[hi] = q
                hi -= 1
            lo >>= 1
            hi >>= 1

    def value(p):
        res = b[p]
        q = -1
        s = p + MED_L
        while s > 0:
            q = max(q, t[s])
            s >>= 1
        if q != -1:
            res = a[x[q] + p - y[q]]
        return res

    result = []
    for j in xrange(m):
        if values[j][0] == 1:
            x[j], y[j], z[j] = values[j][1:]
            x[j] -= 1
            y[j] -= 1
            mark(j, y[j], y[j] + z[j] - 1)
            print 't=%s' % t
        else:
            p = values[j][1] - 1
            result.append(value(p))

    print '\n'.join(map(str, result))


task()
























