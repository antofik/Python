-- --------------------------------------------------------
-- Host:                         catalog.mfst.pro
-- Server version:               5.5.27-1~dotdeb.0-log - (Debian)
-- Server OS:                    debian-linux-gnu
-- HeidiSQL version:             7.0.0.4053
-- Date/time:                    2013-05-01 14:31:14
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET FOREIGN_KEY_CHECKS=0 */;

-- Dumping database structure for algo.pw
CREATE DATABASE IF NOT EXISTS `algo.pw` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */;
USE `algo.pw`;


-- Dumping structure for table algo.pw.auth_group
CREATE TABLE IF NOT EXISTS `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(80) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_group: ~0 rows (approximately)
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;


-- Dumping structure for table algo.pw.auth_group_permissions
CREATE TABLE IF NOT EXISTS `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `group_id` (`group_id`,`permission_id`),
  KEY `auth_group_permissions_425ae3c4` (`group_id`),
  KEY `auth_group_permissions_1e014c8f` (`permission_id`),
  CONSTRAINT `group_id_refs_id_3cea63fe` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`),
  CONSTRAINT `permission_id_refs_id_5886d21f` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_group_permissions: ~0 rows (approximately)
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;


-- Dumping structure for table algo.pw.auth_permission
CREATE TABLE IF NOT EXISTS `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8_unicode_ci NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `content_type_id` (`content_type_id`,`codename`),
  KEY `auth_permission_1bb8f392` (`content_type_id`),
  CONSTRAINT `content_type_id_refs_id_728de91f` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_permission: ~36 rows (approximately)
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` (`id`, `name`, `content_type_id`, `codename`) VALUES
	(1, 'Can add permission', 1, 'add_permission'),
	(2, 'Can change permission', 1, 'change_permission'),
	(3, 'Can delete permission', 1, 'delete_permission'),
	(4, 'Can add group', 2, 'add_group'),
	(5, 'Can change group', 2, 'change_group'),
	(6, 'Can delete group', 2, 'delete_group'),
	(7, 'Can add user', 3, 'add_user'),
	(8, 'Can change user', 3, 'change_user'),
	(9, 'Can delete user', 3, 'delete_user'),
	(10, 'Can add content type', 4, 'add_contenttype'),
	(11, 'Can change content type', 4, 'change_contenttype'),
	(12, 'Can delete content type', 4, 'delete_contenttype'),
	(13, 'Can add session', 5, 'add_session'),
	(14, 'Can change session', 5, 'change_session'),
	(15, 'Can delete session', 5, 'delete_session'),
	(16, 'Can add site', 6, 'add_site'),
	(17, 'Can change site', 6, 'change_site'),
	(18, 'Can delete site', 6, 'delete_site'),
	(19, 'Can add log entry', 7, 'add_logentry'),
	(20, 'Can change log entry', 7, 'change_logentry'),
	(21, 'Can delete log entry', 7, 'delete_logentry'),
	(22, 'Can add tag model', 8, 'add_tagmodel'),
	(23, 'Can change tag model', 8, 'change_tagmodel'),
	(24, 'Can delete tag model', 8, 'delete_tagmodel'),
	(25, 'Can add algorithm model', 9, 'add_algorithmmodel'),
	(26, 'Can change algorithm model', 9, 'change_algorithmmodel'),
	(27, 'Can delete algorithm model', 9, 'delete_algorithmmodel'),
	(28, 'Can add language model', 10, 'add_languagemodel'),
	(29, 'Can change language model', 10, 'change_languagemodel'),
	(30, 'Can delete language model', 10, 'delete_languagemodel'),
	(31, 'Can add implementation model', 11, 'add_implementationmodel'),
	(32, 'Can change implementation model', 11, 'change_implementationmodel'),
	(33, 'Can delete implementation model', 11, 'delete_implementationmodel'),
	(34, 'Can add user profile', 12, 'add_userprofile'),
	(35, 'Can change user profile', 12, 'change_userprofile'),
	(36, 'Can delete user profile', 12, 'delete_userprofile');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;


-- Dumping structure for table algo.pw.auth_user
CREATE TABLE IF NOT EXISTS `auth_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(30) COLLATE utf8_unicode_ci NOT NULL,
  `first_name` varchar(30) COLLATE utf8_unicode_ci NOT NULL,
  `last_name` varchar(30) COLLATE utf8_unicode_ci NOT NULL,
  `email` varchar(75) COLLATE utf8_unicode_ci NOT NULL,
  `password` varchar(128) COLLATE utf8_unicode_ci NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `last_login` datetime NOT NULL,
  `date_joined` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_user: ~1 rows (approximately)
/*!40000 ALTER TABLE `auth_user` DISABLE KEYS */;
INSERT INTO `auth_user` (`id`, `username`, `first_name`, `last_name`, `email`, `password`, `is_staff`, `is_active`, `is_superuser`, `last_login`, `date_joined`) VALUES
	(1, 'root', '', '', 'antofik@gmail.com', 'pbkdf2_sha256$10000$6gXnlqz8RHFV$oHptQ+gJiL7XBkAn6wVTTsnZDRTW4EP9coIDcrNs7Io=', 1, 1, 1, '2013-05-01 09:06:41', '2013-04-27 16:54:12');
/*!40000 ALTER TABLE `auth_user` ENABLE KEYS */;


-- Dumping structure for table algo.pw.auth_user_groups
CREATE TABLE IF NOT EXISTS `auth_user_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`group_id`),
  KEY `auth_user_groups_403f60f` (`user_id`),
  KEY `auth_user_groups_425ae3c4` (`group_id`),
  CONSTRAINT `user_id_refs_id_7ceef80f` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`),
  CONSTRAINT `group_id_refs_id_f116770` FOREIGN KEY (`group_id`) REFERENCES `auth_group` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_user_groups: ~0 rows (approximately)
/*!40000 ALTER TABLE `auth_user_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_groups` ENABLE KEYS */;


-- Dumping structure for table algo.pw.auth_user_user_permissions
CREATE TABLE IF NOT EXISTS `auth_user_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`permission_id`),
  KEY `auth_user_user_permissions_403f60f` (`user_id`),
  KEY `auth_user_user_permissions_1e014c8f` (`permission_id`),
  CONSTRAINT `user_id_refs_id_dfbab7d` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`),
  CONSTRAINT `permission_id_refs_id_67e79cb` FOREIGN KEY (`permission_id`) REFERENCES `auth_permission` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.auth_user_user_permissions: ~0 rows (approximately)
/*!40000 ALTER TABLE `auth_user_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_user_permissions` ENABLE KEYS */;


-- Dumping structure for table algo.pw.django_admin_log
CREATE TABLE IF NOT EXISTS `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime NOT NULL,
  `user_id` int(11) NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `object_id` longtext COLLATE utf8_unicode_ci,
  `object_repr` varchar(200) COLLATE utf8_unicode_ci NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  KEY `django_admin_log_403f60f` (`user_id`),
  KEY `django_admin_log_1bb8f392` (`content_type_id`),
  CONSTRAINT `user_id_refs_id_c8665aa` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`),
  CONSTRAINT `content_type_id_refs_id_288599e6` FOREIGN KEY (`content_type_id`) REFERENCES `django_content_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=113 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.django_admin_log: ~108 rows (approximately)
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
INSERT INTO `django_admin_log` (`id`, `action_time`, `user_id`, `content_type_id`, `object_id`, `object_repr`, `action_flag`, `change_message`) VALUES
	(1, '2013-04-27 16:55:11', 1, 10, '1', 'Python', 1, ''),
	(2, '2013-04-27 17:19:48', 1, 10, '2', 'Python', 1, ''),
	(3, '2013-04-27 17:19:51', 1, 10, '2', 'Python', 2, 'Ни одно поле не изменено.'),
	(4, '2013-04-27 17:20:10', 1, 10, '3', 'C', 1, ''),
	(5, '2013-04-27 17:20:25', 1, 10, '4', 'C++', 1, ''),
	(6, '2013-04-27 17:20:44', 1, 10, '5', 'Java', 1, ''),
	(7, '2013-04-27 17:20:56', 1, 10, '6', 'C#', 1, ''),
	(8, '2013-04-27 17:21:12', 1, 10, '7', 'Clojure', 1, ''),
	(9, '2013-04-27 17:21:30', 1, 10, '8', 'CoffeeScript', 1, ''),
	(10, '2013-04-27 17:22:05', 1, 10, '9', 'Lisp', 1, ''),
	(11, '2013-04-27 17:22:26', 1, 10, '10', 'CSS', 1, ''),
	(12, '2013-04-27 17:22:47', 1, 10, '11', 'D', 1, ''),
	(13, '2013-04-27 17:23:00', 1, 10, '12', 'Diff', 1, ''),
	(14, '2013-04-27 17:23:13', 1, 10, '13', 'ECL', 1, ''),
	(15, '2013-04-27 17:25:09', 1, 10, '14', 'Z80', 1, ''),
	(16, '2013-04-27 17:25:22', 1, 10, '15', 'YAML', 1, ''),
	(17, '2013-04-27 17:25:41', 1, 10, '16', 'XQuery', 1, ''),
	(18, '2013-04-27 17:25:58', 1, 10, '17', 'XML', 1, ''),
	(19, '2013-04-27 17:26:11', 1, 10, '18', 'Velocity', 1, ''),
	(20, '2013-04-27 17:26:23', 1, 10, '19', 'VBScript', 1, ''),
	(21, '2013-04-27 17:27:06', 1, 10, '20', 'VB.NET', 1, ''),
	(22, '2013-04-27 17:27:19', 1, 10, '21', 'Tcl', 1, ''),
	(23, '2013-04-27 17:27:20', 1, 10, '22', 'Tcl', 1, ''),
	(24, '2013-04-27 17:27:33', 1, 10, '22', 'Tcl', 3, ''),
	(25, '2013-04-27 17:27:52', 1, 10, '1', 'Python', 3, ''),
	(26, '2013-04-27 17:28:01', 1, 10, '2', 'Python', 2, 'Изменен lexer.'),
	(27, '2013-04-27 17:28:36', 1, 10, '23', 'SPARQL', 1, ''),
	(28, '2013-04-27 17:28:54', 1, 10, '24', 'SQL', 1, ''),
	(29, '2013-04-27 17:29:07', 1, 10, '25', 'Smarty', 1, ''),
	(30, '2013-04-27 17:29:24', 1, 10, '26', 'Smalltalk', 1, ''),
	(31, '2013-04-27 17:29:36', 1, 10, '27', 'Shell', 1, ''),
	(32, '2013-04-27 17:29:52', 1, 10, '28', 'Scheme', 1, ''),
	(33, '2013-04-27 17:30:38', 1, 10, '29', 'Sass', 1, ''),
	(34, '2013-04-27 17:30:49', 1, 10, '30', 'Rust', 1, ''),
	(35, '2013-04-27 17:31:00', 1, 10, '31', 'Ruby', 1, ''),
	(36, '2013-04-27 17:33:27', 1, 10, '32', 'reStructuredText', 1, ''),
	(37, '2013-04-27 17:33:38', 1, 10, '33', 'R', 1, ''),
	(38, '2013-04-27 17:34:31', 1, 10, '34', 'Properties files', 1, ''),
	(39, '2013-04-27 17:34:58', 1, 10, '35', 'PHP', 1, ''),
	(40, '2013-04-27 17:35:13', 1, 10, '36', 'GFM', 1, ''),
	(41, '2013-04-27 17:36:44', 1, 10, '37', 'Perl', 1, ''),
	(42, '2013-04-27 17:36:57', 1, 10, '38', 'Pascal', 1, ''),
	(43, '2013-04-27 17:37:13', 1, 10, '39', 'OCaml', 1, ''),
	(44, '2013-04-27 17:37:39', 1, 10, '40', 'NTriples', 1, ''),
	(45, '2013-04-27 17:37:52', 1, 10, '41', 'Markdown', 1, ''),
	(46, '2013-04-27 17:38:03', 1, 10, '42', 'Lua', 1, ''),
	(47, '2013-04-27 17:38:15', 1, 10, '43', 'Less', 1, ''),
	(48, '2013-04-27 17:38:52', 1, 10, '44', 'JavaScript', 1, ''),
	(49, '2013-04-27 17:39:13', 1, 10, '45', 'HTTP', 1, ''),
	(50, '2013-04-27 17:39:24', 1, 10, '46', 'HTML', 1, ''),
	(51, '2013-04-27 17:39:35', 1, 10, '47', 'Haxe', 1, ''),
	(52, '2013-04-27 17:39:56', 1, 10, '48', 'Haskell', 1, ''),
	(53, '2013-04-27 17:40:09', 1, 10, '49', 'Groovy', 1, ''),
	(54, '2013-04-27 17:40:20', 1, 10, '50', 'Go', 1, ''),
	(55, '2013-04-27 17:40:32', 1, 10, '51', 'Erlang', 1, ''),
	(56, '2013-04-30 09:00:32', 1, 11, '2', '2.  in CoffeeScript', 3, ''),
	(57, '2013-04-30 09:00:32', 1, 11, '3', '3.  in PHP', 3, ''),
	(58, '2013-04-30 09:00:32', 1, 11, '4', '4.  in Python', 3, ''),
	(59, '2013-04-30 09:00:32', 1, 11, '5', '5. Aho-Corasick string matching in Python', 3, ''),
	(60, '2013-04-30 09:00:32', 1, 11, '6', '6. Fork of Aho-Corasick string matching in Python', 3, ''),
	(61, '2013-04-30 09:00:32', 1, 11, '7', '7.  in PHP', 3, ''),
	(62, '2013-04-30 09:00:32', 1, 11, '8', '8. Fork of  in PHP', 3, ''),
	(63, '2013-04-30 09:00:32', 1, 11, '9', '9.  in Lisp', 3, ''),
	(64, '2013-04-30 09:00:32', 1, 11, '10', '10. Fork of  in Lisp', 3, ''),
	(65, '2013-04-30 09:00:33', 1, 11, '11', '11. Артём-куртём in Python', 3, ''),
	(66, '2013-04-30 09:00:33', 1, 11, '12', '12. Антон Ёжик in Python', 3, ''),
	(67, '2013-04-30 09:00:33', 1, 11, '13', '13. А вот и нифига, это Артём - куртём (а ну не лазь в базу!) :-) in Python', 3, ''),
	(68, '2013-04-30 09:00:33', 1, 11, '14', '14.  in XQuery', 3, ''),
	(69, '2013-04-30 09:00:33', 1, 11, '15', '15.  in C#', 3, ''),
	(70, '2013-04-30 09:00:33', 1, 11, '16', '16.  in PHP', 3, ''),
	(71, '2013-04-30 09:00:33', 1, 11, '17', '17.  in PHP', 3, ''),
	(72, '2013-04-30 09:00:33', 1, 11, '18', '18.  in C', 3, ''),
	(73, '2013-04-30 09:00:33', 1, 11, '19', '19.  in Z80', 3, ''),
	(74, '2013-04-30 09:00:33', 1, 11, '20', '20.  in C++', 3, ''),
	(75, '2013-04-30 09:00:46', 1, 9, '20', '', 3, ''),
	(76, '2013-04-30 09:00:47', 1, 9, '19', '', 3, ''),
	(77, '2013-04-30 09:00:47', 1, 9, '18', '', 3, ''),
	(78, '2013-04-30 09:00:47', 1, 9, '17', '', 3, ''),
	(79, '2013-04-30 09:00:47', 1, 9, '16', '', 3, ''),
	(80, '2013-04-30 09:00:47', 1, 9, '15', '', 3, ''),
	(81, '2013-04-30 09:00:47', 1, 9, '14', '', 3, ''),
	(82, '2013-04-30 09:00:47', 1, 9, '13', 'А вот и нифига, это Артём - куртём (а ну не лазь в базу!) :-)', 3, ''),
	(83, '2013-04-30 09:00:47', 1, 9, '12', 'Антон Ёжик', 3, ''),
	(84, '2013-04-30 09:00:47', 1, 9, '11', 'Артём-куртём', 3, ''),
	(85, '2013-04-30 09:00:47', 1, 9, '10', 'Fork of ', 3, ''),
	(86, '2013-04-30 09:00:47', 1, 9, '9', '', 3, ''),
	(87, '2013-04-30 09:00:47', 1, 9, '8', 'Fork of ', 3, ''),
	(88, '2013-04-30 09:00:47', 1, 9, '7', '', 3, ''),
	(89, '2013-04-30 09:00:47', 1, 9, '6', 'Fork of Aho-Corasick string matching', 3, ''),
	(90, '2013-04-30 09:00:47', 1, 9, '5', 'Aho-Corasick string matching', 3, ''),
	(91, '2013-04-30 09:00:47', 1, 9, '4', '', 3, ''),
	(92, '2013-04-30 09:00:47', 1, 9, '3', '', 3, ''),
	(93, '2013-04-30 09:00:47', 1, 9, '2', '', 3, ''),
	(94, '2013-04-30 09:00:47', 1, 9, '1', '1', 3, ''),
	(95, '2013-04-30 09:02:41', 1, 10, '6', 'C#', 2, 'Изменен example_code.'),
	(96, '2013-04-30 09:03:00', 1, 10, '2', 'Python', 2, 'Изменен example_code.'),
	(97, '2013-04-30 09:03:25', 1, 10, '35', 'PHP', 2, 'Изменен example_code.'),
	(98, '2013-04-30 09:03:45', 1, 10, '44', 'JavaScript', 2, 'Изменен example_code.'),
	(99, '2013-04-30 09:04:08', 1, 10, '46', 'HTML', 2, 'Изменен example_code.'),
	(100, '2013-04-30 09:04:28', 1, 10, '17', 'XML', 2, 'Изменен example_code.'),
	(101, '2013-04-30 09:05:13', 1, 8, '11', 'http://algo.pw/fork/11', 3, ''),
	(102, '2013-04-30 09:05:13', 1, 8, '10', 'Ents', 3, ''),
	(103, '2013-04-30 09:05:13', 1, 8, '9', '3', 3, ''),
	(104, '2013-04-30 09:05:13', 1, 8, '8', '1', 3, ''),
	(105, '2013-04-30 09:05:14', 1, 8, '7', '', 3, ''),
	(106, '2013-04-30 09:05:14', 1, 8, '1', '2', 3, ''),
	(107, '2013-04-30 11:36:37', 1, 9, '23', '', 3, ''),
	(108, '2013-05-01 06:46:13', 1, 9, '37', '', 3, ''),
	(109, '2013-05-01 10:25:47', 1, 9, '39', 'Fork of Apostolico-Giancarlo', 3, ''),
	(110, '2013-05-01 10:27:43', 1, 9, '52', 'Backward Nondeterministic Dawg Matching', 3, ''),
	(111, '2013-05-01 10:30:27', 1, 9, '59', 'Maximal Shift', 3, ''),
	(112, '2013-05-01 10:30:28', 1, 9, '42', 'Horspool', 3, '');
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;


-- Dumping structure for table algo.pw.django_content_type
CREATE TABLE IF NOT EXISTS `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `app_label` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `model` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `app_label` (`app_label`,`model`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.django_content_type: ~12 rows (approximately)
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` (`id`, `name`, `app_label`, `model`) VALUES
	(1, 'permission', 'auth', 'permission'),
	(2, 'group', 'auth', 'group'),
	(3, 'user', 'auth', 'user'),
	(4, 'content type', 'contenttypes', 'contenttype'),
	(5, 'session', 'sessions', 'session'),
	(6, 'site', 'sites', 'site'),
	(7, 'log entry', 'admin', 'logentry'),
	(8, 'tag model', 'main', 'tagmodel'),
	(9, 'algorithm model', 'main', 'algorithmmodel'),
	(10, 'language model', 'main', 'languagemodel'),
	(11, 'implementation model', 'main', 'implementationmodel'),
	(12, 'user profile', 'main', 'userprofile');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;


-- Dumping structure for table algo.pw.django_session
CREATE TABLE IF NOT EXISTS `django_session` (
  `session_key` varchar(40) COLLATE utf8_unicode_ci NOT NULL,
  `session_data` longtext COLLATE utf8_unicode_ci NOT NULL,
  `expire_date` datetime NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_3da3d3d8` (`expire_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.django_session: ~159 rows (approximately)
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` (`session_key`, `session_data`, `expire_date`) VALUES
	('02787ad4ae2adfdcd57fe67c6f92b381', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:32:32'),
	('04c6c78325d6e2a6738ac8a1d8c46508', 'ZjNhZDgxNmI0ODczMWU5MzRmNzJkMTUwYzU4Mzg5YzE1MzRjYWEyZjqAAn1xAShVEl9hdXRoX3Vz\nZXJfYmFja2VuZFUpZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmRVDV9h\ndXRoX3VzZXJfaWSKAQF1Lg==\n', '2013-05-12 08:39:20'),
	('04e908890025e87294863678d2cfbc9a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 09:02:57'),
	('076d1edcb90c434c8da9640fb7e8be48', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:20:34'),
	('07a14558a81c48e43cfa18c57fc23ba0', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:08:36'),
	('07ac1ab0428fedeb0de1d59a54ea7302', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:13:39'),
	('0c2011b3f74d0b3d96a1fb3fd5a3a7bf', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:16:51'),
	('0d0d9f3ececabfc35fed03887a84129c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:44:41'),
	('0dd189c7c44d87f8b6d07d316aac769d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:45:06'),
	('0e7b7554bbaf915cf9c807875c1ccdf8', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:10:59'),
	('0efbb9dd166a02f50bc04add1c8030f7', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:21:33'),
	('0fefc45f367dd2edf0a2359d5d2879b8', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:16'),
	('117f4a78a0a576cab39026368de304fb', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-13 12:17:45'),
	('15b2170d29eb4204efb3ef1b2140dd19', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 13:02:31'),
	('15d593587cc4f0c43448f202fe93b3f4', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:33:02'),
	('17e57fb3e098182d8e411d36c3ff45a6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:36:04'),
	('1bcd771edeaec979176e0702eb8c637d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:28:20'),
	('1cc128753fd272ce459700fac1007b10', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 09:28:22'),
	('1d6667b3f6387c693889b1ec65012b02', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:29:52'),
	('1db5d8c8d3b24826292a1f8541e42dc0', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:52:58'),
	('1db65ded458b7e2f5964612dcb0bf4f9', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:33:57'),
	('20bfdcc785da588c808d164fbed30961', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:22:10'),
	('212c2a2ecce8b48ffdff043bf7875315', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:57:06'),
	('21a07f38f1c335e404725244fba22b54', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 09:26:59'),
	('2431a3a4315411e5b7ca866d04dad0c4', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:40:56'),
	('2497913bc308f3fe97764ff133f5d2d7', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:17:07'),
	('2791289ccc9c0552973f0fc3c255fc29', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:28:43'),
	('27e1fe4168233b288b33a577c5aff799', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:24:02'),
	('29695c90015fbaa9b10267e81c5a86f6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 11:57:13'),
	('2c8a4b73afc4b68a3590c3106bd74056', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:17:54'),
	('2d9272547438958c9d2e4989d2fbd741', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:52:58'),
	('2ebb09aa960dabc78682b1ccf4f9c4dd', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-13 10:01:44'),
	('304e52c2086a8bfd10ee6707cdf21afb', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:17'),
	('320b54a2a155b7e0a22d72268a6250c6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:41:48'),
	('33f401c7f12e0ec0aa0586f8dfeeca94', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:36:16'),
	('34cc1d7d4efdb3bc4b2490cc5085026a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:16:17'),
	('357311ccb495d042b861e6f7f787de29', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:44:51'),
	('36280299d977acb3a4154f2f0c2e622c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:17:38'),
	('369d072121f67497879532672fc72787', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:32:02'),
	('3875d483be439fe753dfc040cef4481d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:22:04'),
	('38ca10274986b41876029ff334e34bab', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:08:26'),
	('401166e89a2e7de2d001c3106a0e830a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:21:08'),
	('42bed9395ca0bfc9e177f930c9c4b47c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:26:26'),
	('42f3e145652b6c688ebee43a72dde14c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:12:01'),
	('4445c314173ae98fe2087f1bb083b083', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:16:12'),
	('4622aed8582a36cd28f3f4b170b7de3a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 21:59:26'),
	('478be1210baf7381b76b2674153af9b3', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:25:02'),
	('47c275c9fca83030637e55f8e1b1c775', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:29:04'),
	('4a67fb1642590c278c0799b250663d25', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:27:41'),
	('4ce65bcbd37615fa0c32695166d1de78', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:36:12'),
	('50c76fb50a20dc852a3170b22d60d361', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:56:50'),
	('53e011b6246e2a42fa872413a3e1bc1d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:27:28'),
	('54fcccd73aaf7f4f5ffea49b1b8e508b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:16:16'),
	('5696f34756b68f22b43a0f6d97b77e37', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:36:05'),
	('56b253b5df98572597aaa6233ff83131', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:16:40'),
	('5923236f36563c9b817d71ff0ebcc184', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 06:22:01'),
	('595db783dae917713dcfef29e90691f2', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:27:11'),
	('5aef98072988cb17ba79ab7cbf5ec969', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:13:20'),
	('5f0c57e7d0ac61c74ac5902a3c7a7519', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:24:45'),
	('60958f15bea5d6cb787bec25682a6214', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:29:49'),
	('628186da854995d4ae5a4628c6c9326a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 09:28:43'),
	('6760ea139b0b9d017a2f12a25b44e984', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:41:21'),
	('68fdb6a95a8331a12a284c4ef0a3f7ea', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:18:10'),
	('697005e45fa5899bbd6d2ef4af3c1eee', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:32:23'),
	('6b42042f978d026c69fdcfedc18fc83e', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:30:16'),
	('6bf108a8e0a37db2bcb95e6b8d30eecb', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:25:33'),
	('6d872bc3e9b1df356ae7eccd6400da04', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:16:04'),
	('6f80c55c2b89260b6b3d59e94950a56c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:26:12'),
	('704759cb48e519b51a72cf215cd141a2', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:21:02'),
	('70787c687982bc75980187027c41f8ff', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:12:21'),
	('71835a84326ed961be6bf5c1dbedb9dc', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:21:35'),
	('721a2223fe850b1589d53bc200d17e49', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:06:05'),
	('739d3e55864dff32732a41b4a90bd025', 'ZjNhZDgxNmI0ODczMWU5MzRmNzJkMTUwYzU4Mzg5YzE1MzRjYWEyZjqAAn1xAShVEl9hdXRoX3Vz\nZXJfYmFja2VuZFUpZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmRVDV9h\ndXRoX3VzZXJfaWSKAQF1Lg==\n', '2013-05-14 11:55:27'),
	('74e9be986b54c331501807542f0154b6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:50:59'),
	('76b796ebd45d82aabe79852f555e390c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:15:36'),
	('7bfbd0e99f04ef10922aea79ead01781', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:36:20'),
	('7e6f802b9cbb4a7c37af0e65beef339c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:17:00'),
	('7e884f008b8fb4420309ebfd48cbcf90', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:26:37'),
	('80f0b296568e64dcc5ec995401ceb611', 'ZjNhZDgxNmI0ODczMWU5MzRmNzJkMTUwYzU4Mzg5YzE1MzRjYWEyZjqAAn1xAShVEl9hdXRoX3Vz\nZXJfYmFja2VuZFUpZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmRVDV9h\ndXRoX3VzZXJfaWSKAQF1Lg==\n', '2013-05-15 10:31:23'),
	('818846155692c64352e150b27244f992', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:30:14'),
	('84ee22a842de62e53f3ec92f2dddfa70', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:17:19'),
	('86753c354146b70fb686234842cf4a83', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:06:31'),
	('88b579691b374fc08f8ed116b3e7abad', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:29:44'),
	('893efcc99460bffe27bbea35a0bbb768', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:52:08'),
	('898b84409e3c4144062746f4742f3f9d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:20:36'),
	('8b77f39ac9bd2e5ab3f4d7aa63286cc5', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:31:41'),
	('8b7f5df10939c28ff6ce0e5b6acd7a3f', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:22:25'),
	('8ee9c6a3bac02b28bca7b144675d5b9f', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 09:31:18'),
	('8f41bed9fb6f06f3a8c6d9526d9634ce', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:05:04'),
	('91f2f63afc1cd037ec997c8316ba845b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 09:24:51'),
	('944f077f6c79626569a0ce66b5d7eaa1', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:11:04'),
	('9462b1e1a49671a9974c7f43e2a88e1d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:23:18'),
	('9562770910a5f6ee40230963a8f5a84d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:10:50'),
	('95802194b20ade0cb8f0644a18deeb6b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:26:19'),
	('9db73e6349c92146a366e6bc0e2e2828', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:58:31'),
	('9f75e0540a3a6b3808bed2f245091dbb', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:18:05'),
	('a025064367308e9530baa08e0f4f1b22', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:17:26'),
	('a04964d13ba7b820de4a9f6b18c2108e', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:07:05'),
	('a1945baed1488bd99e07bc325218ae26', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-13 12:17:44'),
	('a4d31df8c54377e5ca2f09923f496049', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:53:23'),
	('a5b269afdd383135035ec98452b2b0a9', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-13 12:18:05'),
	('a7c8f7d4d7061c0b09c51abb4d851665', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:14:07'),
	('a9881c2cc3407d0837ba45bbbb57439b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:16:00'),
	('aa2dac15ec995ee6450ed2543b69b40f', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:11:37'),
	('ab00602716ea5ff111811243b56e040c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:13:59'),
	('ab885001cb6cc6705f7cd17488cc33ca', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:33:14'),
	('acfd2d6893cccb9385a7af5a7a1da8a7', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:17:26'),
	('ae3a573997e36015760bb0db26f69f28', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:59:59'),
	('aee747202e804960c51b08cdaef6dcca', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:03'),
	('b100ac1057017e27c61330c1c49056f2', 'ZjNhZDgxNmI0ODczMWU5MzRmNzJkMTUwYzU4Mzg5YzE1MzRjYWEyZjqAAn1xAShVEl9hdXRoX3Vz\nZXJfYmFja2VuZFUpZGphbmdvLmNvbnRyaWIuYXV0aC5iYWNrZW5kcy5Nb2RlbEJhY2tlbmRVDV9h\ndXRoX3VzZXJfaWSKAQF1Lg==\n', '2013-05-15 10:24:43'),
	('b212defe89374338a8abfc0aa43344b5', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:22:58'),
	('b4f0e2d01674c7dacfc23fca3d29c96d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:32:48'),
	('b5c53d1a89621511d3a4325812ac7a14', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:03:14'),
	('b5df69ed748058daac8f815327313e24', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:18:15'),
	('b8dc246e867d860ba1a623f4e5019773', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:19'),
	('b97897e0987ba0b279500558a2849610', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:10:02'),
	('bb48c621b1db457e463aa1becbf8edd6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:25:15'),
	('bbceb34b1710e4fc713ed33738e2c364', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:33:07'),
	('bcda63c6541f3fcf0ce18ae40e1bb67d', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:03:27'),
	('bd1bcd0ef91572915478628689be611a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:20'),
	('bfe426d20b192357b0fa44403ddb557a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:22:25'),
	('c066ee6f24dc4c660a54f3f7403c818b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:22:54'),
	('c3f2ed5cdd0d55109d8093967b24bddb', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:39:04'),
	('c51f7f7575e47faf1fbe9454a691c794', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:33:53'),
	('cad6325c20c9056b8afc9e3d1d948e93', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:29:34'),
	('cc31b792d68c6de7b042facb929cee52', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:03:46'),
	('cd7c44aec666cc17b74c24c7e573d618', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:08:29'),
	('cef19fb944022d84be3f18750b5d1f11', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:01:31'),
	('cfb021b67f0c2e0c9995c97f7050e6e6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:26:05'),
	('cff134e572a534231a709144f1fab8f2', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 07:26:24'),
	('d3233618f91ee49ace05e488e06d5ce4', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:08:20'),
	('d3abe1accabb041debd226aac82a9afc', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:31:21'),
	('d415f5fd430cbdee523364dd7427cc4a', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:47:58'),
	('d6ffe4699b68528372e00dea2f6c0bc7', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:11:26'),
	('d8c5781f9dbfeb5ba31dd9001970b30b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:24:25'),
	('da292e2b01362b3908fe9dbf5aa3d7ee', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:21:01'),
	('da5dba05a883dffdf5cf90aa9d7cc55b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:03:59'),
	('df4fe93d6dbdbfb5bae05e9a2017ea90', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:22'),
	('e581414ae62108a6995e9b910f6a873e', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:14:29'),
	('e59378fb944b5f775bc3acf1c09f5bff', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:23:48'),
	('e6690bcd26b45aa8642aa7264a61474c', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:56:52'),
	('e6d51af689889940517e40a55755836e', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:20:02'),
	('e817afca9b7f4e2ecea94c2cca5827db', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:08'),
	('e9bfea325e7448655fecc0ce58c23481', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:22:11'),
	('ea5bfd51e710af11898225d5394f1237', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 11:42:24'),
	('ead7fd869ca102cac3af8315aeafb767', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:11:24'),
	('eb1fc43701e962c7a782a0dc649e97cd', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:20:23'),
	('ed1638b8a05216b9cd15e93e71302d8b', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:34:21'),
	('edb1f30b03e9cbdc81d5330aef04b146', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:57:28'),
	('ee796b23b0efdb3fa01e85ba650ac48f', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:28:00'),
	('eed21470e3c42a192b744a42d2004946', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:56:33'),
	('f06df25b2b5feafd0fb819393a5b8625', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:33:18'),
	('f3146ae5a5fb54ccecf678f81863e3bf', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:22:59'),
	('f455c79aeb91f33092ffc7e3a78c53e6', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:13:43'),
	('f46987011ff48c8b660c13e1bfc7cae1', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 13:02:58'),
	('f541fe9c4fcafdbb9cf42fab7e21ef82', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 08:52:14'),
	('fa85207838507204032f4b676c440ea5', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-12 08:22:04'),
	('fb66d5a0cc8bd884f40bd2718f965a78', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-11 18:29:26'),
	('fe50e11e23f4aef129177fcffa8f9312', 'OTE0Yjk1M2VjMThmNGZkOGY1MGJlNTIwMmI1MTNkNzhkZDg3YTBkODqAAn1xAS4=\n', '2013-05-14 10:15:59');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;


-- Dumping structure for table algo.pw.django_site
CREATE TABLE IF NOT EXISTS `django_site` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `domain` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `name` varchar(50) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.django_site: ~1 rows (approximately)
/*!40000 ALTER TABLE `django_site` DISABLE KEYS */;
INSERT INTO `django_site` (`id`, `domain`, `name`) VALUES
	(1, 'example.com', 'example.com');
/*!40000 ALTER TABLE `django_site` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_algorithmmodel
CREATE TABLE IF NOT EXISTS `main_algorithmmodel` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) COLLATE utf8_unicode_ci NOT NULL,
  `authors` varchar(256) COLLATE utf8_unicode_ci NOT NULL,
  `description` longtext COLLATE utf8_unicode_ci NOT NULL,
  `date_added` datetime NOT NULL,
  `date_modified` datetime NOT NULL,
  `fork_of_id` int(11) DEFAULT NULL,
  `key` varchar(256) COLLATE utf8_unicode_ci DEFAULT NULL,
  `verified` tinyint(4) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `main_algorithmmodel_9ec7b8d` (`fork_of_id`),
  CONSTRAINT `fork_of_id_refs_id_40ff3d85` FOREIGN KEY (`fork_of_id`) REFERENCES `main_algorithmmodel` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=64 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_algorithmmodel: ~37 rows (approximately)
/*!40000 ALTER TABLE `main_algorithmmodel` DISABLE KEYS */;
INSERT INTO `main_algorithmmodel` (`id`, `name`, `authors`, `description`, `date_added`, `date_modified`, `fork_of_id`, `key`, `verified`) VALUES
	(21, 'Hello world', '', 'Simple program that prints string "Hello, world!" into standard output device.', '2013-04-30 09:07:56', '2013-04-30 09:50:43', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(22, 'Bogo sort', '', 'A naive sorting that picks two elements at random and swaps them.<br><br>    Time Complexity: <strong>O(n * n!)</strong><br><br>    Space Complexity: <strong>O(1) Auxiliary</strong><br><br>    Stable: No<br><p><br></p><p><strong>WARNING</strong>: This algorithm may never sort the list correctly.<br></p>', '2013-04-30 10:03:21', '2013-04-30 10:04:19', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(24, 'Brute Force', '', '<div>&nbsp; &nbsp; The brute force algorithm consists in checking, at all positions in the text between 0 and n-m, whether an occurrence of the pattern starts there or not. Then, after each attempt, it shifts the pattern by exactly one position to the right.</div><div><br></div><div>&nbsp; &nbsp; The brute force algorithm requires no preprocessing phase, and a constant extra space in addition to the pattern and the text. During the searching phase the text character comparisons can be done in any order. The time complexity of this searching phase is O(mn) (when searching for am-1b in an for instance). The expected number of text character comparisons is 2n.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">no preprocessing phase;</span><br></li><li><span style="line-height: normal;">constant extra space needed;</span><br></li><li><span style="line-height: normal;">always shifts the window by exactly 1 position to the right;</span><br></li><li><span style="line-height: normal;">comparisons can be done in any order;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity;</span><br></li><li><span style="line-height: normal;">2n expected text characters comparisons.</span><br></li></ul></div></div>', '2013-04-30 10:37:11', '2013-04-30 10:57:29', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(25, 'Deterministic Finite Automaton', '', '<div>&nbsp; &nbsp; Searching a word x with an automaton consists first in building the minimal Deterministic Finite Automaton (DFA) &nbsp;A(x) recognizing the language *x.</div><div>The DFA &nbsp;A(x) =(Q, q0, T, E) recognizing the language *x is defined as follows: <span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><ul><li><span style="line-height: normal;"><i>Q is the set of all the prefixes of x: Q={, x[0], x[0 .. 1], ... , x[0 .. m-2], x};</i></span></li><li><i><span style="line-height: normal;">q0=E;</span><span style="line-height: normal;">&nbsp;</span></i></li><li><i><span style="line-height: normal;">T={x};</span><span style="line-height: normal;">&nbsp;</span></i></li><li><span style="line-height: normal;"><i>for q in Q (q is a prefix of x) and a in , (q, a, qa) is in E if and only if qa is also a prefix of x, otherwise (q, a, p) is in E such that p is the longest suffix of qa which is a prefix of x.</i></span></li></ul></div><div><br></div><div>&nbsp; &nbsp; The DFA &nbsp;A(x) can be constructed in O(m+) time and O(m) space.</div><div><br></div><div>&nbsp; &nbsp; Once the DFA &nbsp;A(x) is build, searching for a word x in a text y consists in parsing the text y with the DFA &nbsp;A(x) beginning with the initial state q0. Each time the terminal state is encountered an occurrence of x is reported.</div><div><br></div><div>&nbsp; &nbsp; The searching phase can be performed in O(n) time if the automaton is stored in a direct access table, in O(nlog()) otherwise.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">builds the minimal deterministic automaton recognizing the language *x;</span><br></li><li><span style="line-height: normal;">extra space in O(m) if the automaton is stored in a direct access table;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m) time complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n) time complexity if the automaton is stored in a direct access table, O(nlog()) otherwise.</span><br></li></ul></div></div>', '2013-04-30 10:44:06', '2013-04-30 10:47:54', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(26, 'Karp-Rabin', '', '<div>&nbsp; &nbsp; Hashing provides a simple method to avoid a quadratic number of character comparisons in most practical situations. Instead of checking at each position of the text if the pattern occurs, it seems to be more efficient to check only if the contents of the window “looks like” the pattern. In order to check the resemblance between these two words an hashing function is used.</div><div><br></div><div>&nbsp; &nbsp; To be helpful for the string matching problem an hashing function hash should have the following properties: <span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><br></div><div><ul><li><i><span style="line-height: normal;">efficiently computable;</span><span style="line-height: normal;">&nbsp;</span></i></li><li><i><span style="line-height: normal;">highly discriminating for strings;</span><span style="line-height: normal;">&nbsp;</span></i></li><li><i><span style="line-height: normal;">hash(y[j+1 .. j+m]) must be easily computable from hash(y[j .. j+m-1]) and y[j+m]:</span><br></i></li><li><span style="line-height: normal;"><i>hash(y[j+1 .. j+m])= rehash(y[j], y[j+m], hash(y[j .. j+m-1]).</i></span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div>&nbsp; &nbsp; For a word w of length m let hash(w) be defined as follows:<br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<i>hash(w[0 .. m-1])=(w[0]*2m-1+ w[1]*2m-2+···+ w[m-1]*20) mod q</i></div><div>&nbsp;where q is a large number.</div><div><br></div><div>Then, <i>rehash(a,b,h)= ((h-a*2m-1)*2+b) mod q</i></div><div><br></div><div>The preprocessing phase of the Karp-Rabin algorithm consists in computing hash(x). It can be done in constant space and O(m) time.</div><div><br></div><div>During searching phase, it is enough to compare hash(x) with hash(y[j .. j+m-1]) for 0 &nbsp;j &lt; n-m. If an equality is found, it is still necessary to check the equality x=y[j .. j+m-1] character by character.</div><div><br></div><div>The time complexity of the searching phase of the Karp-Rabin algorithm is O(mn) (when searching for am in an for instance). Its expected number of text character comparisons is O(n+m).</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">uses an hashing function;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m) time complexity and constant space;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity;</span><br></li><li><span style="line-height: normal;">O(n+m) expected running time.</span><br></li></ul></div></div>', '2013-04-30 10:48:21', '2013-04-30 10:50:09', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(27, 'Shift Or', '', '<div>he Shift Or algorithm uses bitwise techniques. Let R be a bit array of size m. Vector Rj is the value of the array R after text character y[j] has been processed (see figure 5.1). It contains informations about all matches of prefixes of x that end at position j in the text for 0 &lt; i &nbsp;m-1:</div><div><br></div><div><img src="data:image/gif;base64,R0lGODlhhgExAIAAAAAAAL+/vyH5BAEAAAEALAAAAACGATEAAAL+jI+py+0Po5y02gau3rz7D4biSJYmCWTnyrbuC8fy/KT0jef6zveU7QsKh8SikQE8XlLJDlPFevakymq1+cIGmCCox+s9hRVjSbmGOFvXPC3EPcGqNWV43DXP5dn8mR1psPczMqYiiIFXdNjHGLW4lRbyGBEGtjFJp9i4ifNHFtlFmGCZ2YKZxZkq4zkKagH0xIqUAdt6IKh16kB6JrvgG1ioOoz3SLpki1xb6borPBtL9QllCHgKDMlMvG2CffyaXFHdDHn7Vk7OMU79iz64SPvJPS/inX53P0j+vSsvaR4IUZpo0gLqy0cvoThjCM81pBTOHa529QC6i4jvoEX+hRxfMdwoDmPIctoMoilJhiAXQFvYsQT38WHHVSt/1ZQ0aVwpkGaCoXsGptezfxJfepzlDxS2mSXm8PuwtKW6JAXN0HoqdSBSkVOb9LokNCnAqExrEBQIkZAuJfA0VuRpUpRIl2XrUfvaU63Cthnfwr1I9B7dulCDGkWjNyHfvFBB1hHDdTBhJ4YppsXJ8VBOu0N9dtPKcu3klLfU1OlcOPPNrqLjrO70ejTlqgZPiw2m0mlr2bx7i7nbrxVqdb6LG28DHC3G3aCPO39uKvlhnsybQ7+OPbVn0I9vt8xtNrv48Udx/yTZDmWX6t3YY3BPvnc03Mdsc50KDgZ8m/Hf+/u1L1N5Vu1HnX8GriFZcHbl15R3Bz44RYBxrcdgYhJCiKF+F+4XFXNeFXRVSkHBQuJVhlTyIYEZ0iNHbPShgMluOk2YlTaWUOUZSjPOuGKPNFWIzEZD1ZfOiRPyYpGKPi75HpAVPjVYLEWip16KZDGJpYB9BRnXkPkIU416JimZZZnWMbZTUUT+hVd3tf1lZpzauRUkM2uOJZiR4ew4JplyQugNbQtZ9t12hr7GT02IVvZnoz/46Wik0F0paaUHUmpppuRhqmmn2HHqaajGgSpqqbyRamqqhEGqqgkFAAA7"><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div><br></div><div>&nbsp;&nbsp;</div><div style="text-align: center;"><b>Figure 5.1</b>: Meaning of vector Rj.</div><div><br></div><div>The vector Rj+1 can be computed after Rj as follows. For each Rj[i]=0:</div><div><img src="data:image/gif;base64,R0lGODlhoAExAIAAAAAAAL+/vyH5BAEAAAEALAAAAACgATEAAAL+jI+py+0Po5y02isB3rz7D4biSJbmiTKAlrbuC8fyTNfVauf6zvf+D8IBh8Si8YjECJO3FSvmfJqiLyrzim3Olgdn0CE9hUnjRPlzzqrXAW4mHXHDL3PRud7Bc+7svt8NwaKXMTKoEgdoYEinFJjY5hep9njYFbIYmDfBh4KpSLjgKTm6ZSglGlqoCaqAynrziuBKSptCmWpJJxgliiN0hzfIiSb7GQqnN1y73HPbWtwIzfgLeRy3WWnGy3v4JNjdkJzNTJ7jbCZtEdZrnIsejI27+t1ejBzrXq5fSnG6sb4qH7pj27yEGxfQ20FZBQ3KG7gvIoxz6VAB3AMxI5j+eM++tEtz79pDiSTFmEoHC6U6Y3zqCEOoqCGlXQJV2hxZs2Qnh1V4BllEL1rOTG00KLRGVGRHYtXq3Ry6dCBFnRjNkcE0VcUSK/2M+kP6IBhXqOp4KsPZaizLWVkaeoT5D24etkRmsaWb8WxURk5JbqVr15FeD1nbBoxrRyPZpkLxXuFSeCHipIoJO/5xWWhVxpz7klnMDDLgwxvR7snsA/VKNIDWqe742sjft5pL77WsT60L3YV8moxca5vpsFqVEkcr8xZwqsyb//MW2HNR47Yr13aOPfsl6PgcljGqVaZk60piaz8vcTZ1dyDXy828HL387OoZ3v4o977p78n+w5qfD+Aof4EX035DEVhdgqCVdUR8XQUIYVFWjAWdcNIA4542vqEG3H/kbRdhiO4NgyFlfNlhioMmdiZii1C8t6CCKaG4WgljeOhijvrdaBCOMs5VY2/66UjkZ8PFKMZVQT7HkFnTadjkLlJKWGCTVhbZnCu87aRicTMidpF9nAUFyVZVhlnNVz5iuUOX5XR42FcXzlkTTWNCcxSLbO4ZCZybMXZjPtzUmeadYsbkG5+KsuHnZIAuJadiBCLoWZ6LXtonVnHaQ6d0nHyHJ5KYjjpEo2C+0ylLNv0SaC5qdrEmqbJqscmWtT7Uo2tXVgQlomkdOmuwPLh5XqzCHusn5aXGIsssrKMu2yyzxNIXbbVQQGtttlhOq223x3LrbbiyYituCQUAADs="><br></div><div><br></div><div>&nbsp;and</div><div><img src="data:image/gif;base64,R0lGODlhgQExAIAAAAAAAL+/vyH5BAEAAAEALAAAAACBATEAAAL+jI+py+0Po5y02isB3rz7D4biSJbm+QAayrbuC8fyDKv0jef6zvfp6gsKh8Si0WA7YlRJBhN4er6kyqq106xBkVnONtX6JsQf8vWMXnQja0rXvFSL4SC6h2xP661txyo/ARio8EcYFveDt7fI2OeEIAgRyTYGWckyeQCoyNiJ5qhmWTeyBVV6eLH56MlaBWqoufT3lMkVkHQaKzqqiwenGtoqXPR6ibSRm3pbmHxrPEZL+whUGGoGDDus7VO864yoa1Edfkz+fVdObe2Xsbr9rtNNXltuLv58nq+PFX4NHc2kASd4BGnIq7dvkDdlC03h41fPn8B2wQpa1OJmYUb+jRWqNWsGCWDAVU0kugNT8WInKk5GijiYzstDSsvOfRlnT2a+gSfZBYOpMkgken4yAf2nyWUgDVnmzHmplGfKlkrTEQ0qCSAvaFPLXDUytITDrjM3JsQaouRXhDHLellLJCypsnS+qkMr1hTcj26RwR0iFx3bp5hy4r2jt8wzkIgJBkZ8kyuqv4cl11TsjTEWykJYyjkqrmoU0ZXTSstmFqFmkaSTln4N27RrnfrGGmYYO7fu0LMlESq5uC/v3cSLt+yNMhtfjm+NO3eu9jfqXctzsn4F+rn2bWqZIjd8V1RkUpxJZHdTfvueaFyaJmVPXQ7ZzfdqhEmvviBh5anb6ww975tw+Q0413zh0QRVfWJNR2CDC3ZFxWP+KUgegw5euJWAEnpFoV8hRXXZhx/OQuIysyD1HoZoXeXZbwAe15FgjOFyiUPAXbbcWPipKNSOGMVI20789aPRibWJRySPSv7YH4W2Jdmee5Uwg09TLS6JZV4dOlnkPD05QyVHB2ZJpglH2ZWZkKp92VZwNpUJp5lGyThlfEhaZ2SaalLjY5wNwnSah6iN9IZe4w3WnXTf+cloVo0+CqllkU7q54uUXlqcpZhumpumnH56mKegjhqUqKSeqh+qMRQAADs="><br></div><div><br></div><div>If Rj+1[m-1]=0 then a complete match can be reported.</div><div><br></div><div>The transition from Rj to Rj+1 can be computed very fast as follows: For each c in , let Sc be a bit array of size m such that: for 0 &nbsp;i &lt; m-1, Sc[i]=0 iff x[i]=c.</div><div><br></div><div>The array Sc denotes the positions of the character c in the pattern x. Each Sc can be preprocessed before the search. And the computation of Rj+1 reduces to two operations, shift and or: Rj+1=SHIFT(Rj) OR Sy[j+1]</div><div><br></div><div>Assuming that the pattern length is no longer than the memory-word size of the machine, the space and time complexity of the preprocessing phase is O(m+q).</div><div><br></div><div>The time complexity of the searching phase is O(n), thus independent from the alphabet size and the pattern length.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">uses bitwise techniques;</span><br></li><li><span style="line-height: normal;">efficient if the pattern length is no longer than the memory-word size of the machine;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m + ) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n) time complexity (independent from the alphabet size and the pattern length);</span><br></li><li><span style="line-height: normal;">adapts easily to approximate string matching.</span><br></li></ul></div></div>', '2013-04-30 10:50:17', '2013-04-30 10:54:01', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(28, 'Morris-Pratt', '', '<div>&nbsp; &nbsp; The design of the Morris-Pratt algorithm follows a tight analysis of the Brute Force algorithm, and especially on the way this latter wastes the information gathered during the scan of the text.</div><div><br></div><div>&nbsp; &nbsp; Let us look more closely at the brute force algorithm. It is possible to improve the length of the shifts and simultaneously remember some portions of the text that match the pattern. This saves comparisons between characters of the pattern and characters of the text and consequently increases the speed of the search.</div><div><br></div><div>&nbsp; &nbsp; Consider an attempt at a left position j on y, that is when the window is positioned on the text factor y[j .. j+m-1]. Assume that the first mismatch occurs between x[i] and y[i+j] with 0 &lt; i &lt; m. Then, x[0..i-1] = y[j .. i+j-1] = u and a = x[i] &nbsp;y[i+j]=b.</div><div><br></div><div>&nbsp; &nbsp; When shifting, it is reasonable to expect that a prefix v of the pattern matches some suffix of the portion u of the text. The longest such prefix v is called the border of u (it occurs at both ends of u). This introduces the notation: let mpNext[i] be the length of the longest border of x[0 .. i-1] for 0 &lt; i &nbsp;m. Then, after a shift, the comparisons can resume between characters c=x[mpNext[i]] and y[i+j]=b without missing any occurrence of x in y, and avoiding a backtrack on the text (see figure 6.1). The value of mpNext[0] is set to -1.</div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;"><b>Figure 6.1</b>: &nbsp;Shift in the Morris-Pratt algorithm (v border of u).</div><div><br></div><div>The table mpNext can be computed in O(m) space and time before the searching phase, applying the same searching algorithm to the pattern itself, as if x=y.</div><div><br></div><div>Then the searching phase can be done in O(m+n) time. The Morris-Pratt algorithm performs at most 2n-1 text character comparisons during the searching phase. The delay (maximal number of comparisons for a single text character) is bounded by m.</div>', '2013-04-30 10:55:18', '2013-04-30 10:56:49', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(29, 'Knuth-Morris-Pratt', '', '<div>&nbsp; &nbsp; The design of the Knuth-Morris-Pratt algorithm follows a tight analysis of the Morris and Pratt algorithm. Let us look more closely at the Morris-Pratt algorithm. It is possible to improve the length of the shifts.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;Consider an attempt at a left position j, that is when the the window is positioned on the text factor y[j .. j+m-1]. Assume that the first mismatch occurs between x[i] and y[i+j] with 0 &lt; i &lt; m. Then, x[0 .. i-1] = y[j .. i+j-1] =u and a = x[i] &nbsp;y[i+j]=b.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;When shifting, it is reasonable to expect that a prefix v of the pattern matches some suffix of the portion u of the text. Moreover, if we want to avoid another immediate mismatch, the character following the prefix v in the pattern must be different from a. The longest such prefix v is called the tagged border of u (it occurs at both ends of u followed by different characters in x).</div><div><br></div><div>&nbsp; &nbsp;&nbsp;This introduces the notation: let kmpNext[i] be the length of the longest border of x[0 .. i-1] followed by a character c different from x[i] and -1 if no such tagged border exits, for 0 &lt; i &nbsp;m. Then, after a shift, the comparisons can resume between characters x[kmpNext[i]] and y[i+j] without missing any occurrence of x in y, and avoiding a backtrack on the text (see figure 7.1). The value of kmpNext[0] is set to -1.</div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;">&nbsp; &nbsp;&nbsp;<b>Figure 7.1</b>: Shift in the Knuth-Morris-Pratt algorithm (v border of u and c <img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;b).</div><div><br></div><div>&nbsp; &nbsp;&nbsp;The table kmpNext can be computed in O(m) space and time before the searching phase, applying the same searching algorithm to the pattern itself, as if x=y.</div><div><br></div><div>&nbsp; &nbsp; The searching phase can be performed in O(m+n) time. The Knuth-Morris-Pratt algorithm performs at most 2n-1 text character comparisons during the searching phase. The delay (maximal number of comparisons for a single text character) is bounded by log(m) where &nbsp;is the golden ratio (<img src="data:image/gif;base64,R0lGODlhXwAfAIAAAAAAAL+/vyH5BAEAAAEALAAAAABfAB8AAAKwjI+py+2fgJy0wouzbmD7D4LdMXLhiTplsLIT0qYiE6twtNRy9ub8jfPtQrqiYhXrAYcf47EFPRqizCasIgmStNJlxFL1ipfJLpWmYzqFrC7wnEsP1z76FP6lhO9Zd512UdSR1bcnIifXFnfHGIeltJd42Fi483iJman5+OXiaQh6ghVKKiqpGVoZplr6o1g12qoxIilry3Wba6LLy9b7+wr8Oyjcq1eMnKy8zNycXAAAOw==">).</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">performs the comparisons from left to right;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m) space and time complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n+m) time complexity (independent from the alphabet size);</span><br></li><li><span style="line-height: normal;">delay bounded by log</span><font size="1" style="line-height: normal;"><img src="data:image/gif;base64,R0lGODlhCgAMAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAKAAwAAAIYTIBpe8CMXkvOxOtis2pv7E0dVEkaSRkFADs="></font><span style="line-height: normal;">(m) where&nbsp;</span><img src="data:image/gif;base64,R0lGODlhCgAMAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAKAAwAAAIYTIBpe8CMXkvOxOtis2pv7E0dVEkaSRkFADs=" style="line-height: normal;"><span style="line-height: normal;">&nbsp;is the golden ratio (</span><img src="data:image/gif;base64,R0lGODlhXwAfAIAAAAAAAL+/vyH5BAEAAAEALAAAAABfAB8AAAKwjI+py+2fgJy0wouzbmD7D4LdMXLhiTplsLIT0qYiE6twtNRy9ub8jfPtQrqiYhXrAYcf47EFPRqizCasIgmStNJlxFL1ipfJLpWmYzqFrC7wnEsP1z76FP6lhO9Zd512UdSR1bcnIifXFnfHGIeltJd42Fi483iJman5+OXiaQh6ghVKKiqpGVoZplr6o1g12qoxIilry3Wba6LLy9b7+wr8Oyjcq1eMnKy8zNycXAAAOw==" style="line-height: normal;"><div style="line-height: normal; display: inline !important;">).</div><br></li></ul></div></div>', '2013-04-30 10:58:26', '2013-04-30 18:33:24', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(30, 'Simon', '', '<div>&nbsp; &nbsp; The main drawback of the search with the minimal &nbsp;A(x) (see Deterministic Finite Automaton) is the size of the automaton: O(m<img src="data:image/gif;base64,R0lGODlhCAAIAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAIAAgAAAIOTIB5tgb8mpuQyigPYqEAOw==">).</div><div><br></div><div>&nbsp; &nbsp;&nbsp;Simon noticed that there are only a few significant edges in &nbsp;A(x) ;</div><div>they are:&nbsp;</div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><ul><li><span style="line-height: normal;">the forward edges going from the prefix of x of length k to the prefix of length k+1 for 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;k &lt; m. There are exactly m such edges;</span><br></li><li><span style="line-height: normal;">the backward edges going from the prefix of x of length k to a smaller non-zero length prefix. The number of such edges is bounded by m.</span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div>&nbsp; &nbsp;&nbsp;The other edges are leading to the initial state and can then be deduced. Thus the number of significant edges is bounded by 2m. Then for each state of the automaton it is only necessary to store the list of its significant outgoing edges.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;Each state is represented by the length of its associated prefix minus 1 in order that each edge leading to state i, with -1 &nbsp;i &nbsp;m-1 is labelled by x[i] thus it is not necessary to store the labels of the edges. The forward edges can be easily deduced from the pattern, thus they are not stored. It only remains to store the significant backward edges.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;We use a table L, of size m-2, of linked lists. The element L[i] gives the list of the targets of the edges starting from state i. In order to avoid to store the list for the state m-1, during the computation of this table L, the integer &nbsp;is computed such that +1 is the length of the longest border of x.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;The preprocessing phase of the Simon algorithm consists in computing the table L and the integer . It can be done in O(m) space and time complexity.</div><div><br></div><div>&nbsp; &nbsp;&nbsp;The searching phase is analogous to the one of the search with an automaton. When an occurrence of the pattern is found, the current state is updated with the state . This phase can be performed in O(m+n) time. The Simon algorithm performs at most 2n-1 text character comparisons during the searching phase. The delay (maximal number of comparisons for a single text character) is bounded by min{1+log2(m),&nbsp;<img src="data:image/gif;base64,R0lGODlhCAAIAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAIAAgAAAIOTIB5tgb8mpuQyigPYqEAOw==">}.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">economical implementation of &nbsp;A(x) the minimal Deterministic Finite Automaton recognizing&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAMAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAKAAwAAAIXhI8XuxbKXgNRzkhnrm9Xv3mWKDlYghYAOw==">*x;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(m+n) time complexity (independent from the alphabet size);</span><br></li><li><span style="line-height: normal;">at most 2n-1 text character comparisons during the searching phase;</span><br></li><li><span style="line-height: normal;">delay bounded by min{1 + log2m,&nbsp;<img src="data:image/gif;base64,R0lGODlhCAAIAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAIAAgAAAIOTIB5tgb8mpuQyigPYqEAOw==">}.</span><br></li></ul></div></div>', '2013-04-30 11:01:22', '2013-04-30 11:04:44', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(31, 'Colussi', '', '<div>For 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;m-1: kmin[i]= d&gt;0 iff x[0 .. i-1-d]=x[d .. i-1] and x[i-d]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;x[i], 0 otherwise.</div><div><br></div><div>When kmin&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;0 a periodicity ends at position i in x.</div><div><br></div><div>For 0 &lt; i &lt; m if kmin[i-1] &nbsp;0 then i is a nohole otherwise i is a hole.</div><div><br></div><div>Let nd+1 be the number of noholes in x.</div><div>The table h contains first the nd+1 noholes in increasing order and then the m-nd-1 holes in decreasing order:&nbsp;</div><div><br><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><ul><li><span style="line-height: normal;">for 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;nd, h[i] is a nohole and h[i] &lt; h[i+1] for 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i&lt;nd;</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">for nd &lt; i &lt; m, h[i] is a hole and h[i] &gt; h[i+1] for nd &lt; i &lt; m-1.</span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div><br></div><div>If i is a hole then rmin[i] is the smallest period of x greater than i.</div><div><br></div><div>The value of first[u] is the smallest integer v such that u&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;h[v].</div><br><div>Then assume that x is aligned with y[j .. j+m-1]. If x[h[k]]=y[j+h[k]] for 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;k &lt; r &lt; nd and x[h[r]]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[j+h[r]]. Let j’ = j+kmin[h[r]].</div><div><div>Then there is no occurrence of x beginning in y[j .. j’] and x can be shifted by kmin[h[r]] positions to the right.</div><div>Moreover x[h[k]]=y[j’+h[k]] for 0 &nbsp;k &lt; first[h[r]-kmin[h[r]]] meaning that the comparisons can be resume with x[h[first[h[r]-kmin[h[r]]]]] and y[j’+h[first[h[r]-kmin[h[r]]]]].</div><div><br></div><div style="text-align: center;">&nbsp;&nbsp;<img src="data:image/gif;base64,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"></div><div><br></div><div style="text-align: center;"><b>Figure 9.1</b>: Mismatch with a nohole. Noholes are black circles and are compared from left to right.</div><div>In this situation, after the shift, it is not necessary to compare the first two noholes again.</div><div><br></div><div>If x[h[k]]=y[j+h[k]] for 0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;k &lt; r and x[h[r]]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[j+h[r]] with nd &nbsp;r &lt; m. Let j’=j+rmin[h[r]]. Then there is no occurrence of x beginning in y[j .. j’] and x can be shifted by kmin[h[r]] positions to the right.</div><div>&nbsp;Moreover x[0 .. m-1-rmin[h[r]]]=y[j’ .. j+m-1] meaning that the comparisons can be resume with x[h[first[m-1-rmin[h[r]]]]] and y[j’+h[first[m-1-rmin[h[r]]]]].</div><div><br></div><div style="text-align: center;">&nbsp;&nbsp;<img src="data:image/gif;base64,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"></div><div style="text-align: center;"><b>Figure 9.2</b>: Mismatch with a hole. Noholes are black circles and are compared from left to right</div><div>&nbsp;while holes are white circles and are compared from right to left.</div><div>In this situation, after the shift, it is not necessary to compare the matched prefix of the pattern again.</div><div><br></div><div>To compute the values of kmin, a table hmax is used and defined as follows: hmax[k] is such that x[k .. hmax[k]-1]=x[0 .. hmax[k]-k-1] and x[hmax[k]]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;x[hmax[k]-k].</div><div><br></div><div>The value of nhd0[i] is the number of noholes strictly smaller than i.</div><div>We can now define two functions shift and next as follows:&nbsp;</div><div><br></div><div><ul><li><span style="line-height: normal;">shift[i]=kmin[h[i]] and next[i]=nhd0[h[i]-kmin[h[i]]] for i &lt; nd;</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">shift[i]=rmin[h[i]] and next[i]=nhd0[m-rmin[h[i]]] for nd&nbsp;</span><img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7" style="line-height: normal;"><span style="line-height: normal;">&nbsp;i &lt; m;</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">shift[m]=rmin[0] and next[m]=nhd0[m-rmin[h[m-1]]].</span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div>Thus, during an attempt where the window is positioned on the text factor y[j .. j+m-1], when a mismatch occurs between x[h[r]] and y[j+h[r]] the window must be shifted by shift[r] and the comparisons can be resume with pattern position h[next[r]].</div><div><br></div><div>The preprocessing phase can be done in O(m) space and time. The searching phase can then be done in O(n) time complexity and furthermore at most n text character comparisons are performed during the searching phase.</div></div>', '2013-04-30 11:05:19', '2013-04-30 11:12:24', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(32, 'Galil-Giancarlo', '', '<div>&nbsp; &nbsp; The Galil-Giancarlo algorithm is a variant of the Colussi algorithm. The change intervenes in the searching phase. The method applies when x is not a power of a single character. Thus x &nbsp;cm with c in .</div><div><br></div><div>&nbsp; &nbsp; Let &nbsp;be the last index in the pattern such that for 0 &nbsp;i &nbsp;, x[0]=x[i] and x[0] &nbsp;x[+1]. Assume that during the previous attempt all the noholes have been matched and a suffix of the pattern has been matched meaning that after the corresponding shift a prefix of the pattern will still match a part of the text. Thus the window is positioned on the text factor y[j .. j+m-1] and the portion y[j .. last] matches x[0 .. last-j]. Then during the next attempt the algorithm will scanned the text character beginning with y[last+1] until either the end of the text is reached or a character x[0] &nbsp;y[j+k] is found.</div><div>In this latter case two subcases can arise: <span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><br></div><div><ul><li><span style="line-height: normal;">x[+1] &nbsp;y[j+k] or too less x[0] have been found (k &nbsp;) then the window is shifted and positioned on the text factor y[k+1 .. k+m], the scanning of the text is resumed (as in the Colussi algorithm) with the first nohole and the memorized prefix of the pattern is the empty word.</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">x[+1]=y[j+k] and enough of x[0] has been found (k &gt; ) then the window is shifted and positioned on the text factor y[k--1 .. k-+m-2], the scanning of the text is resumed (as in the Colussi algorithm) with the second nohole (x[+1] is the first one) and the memorized prefix of the pattern is x[0 .. +1].</span></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div>&nbsp; &nbsp; The preprocessing phase is exactly the same as in the Colussi algorithm and can be done in O(m) space and time.</div><div><br></div><div>&nbsp; &nbsp; The searching phase can then be done in O(n) time complexity and furthermore at most n text character comparisons are performed during the searching phase.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;">refinement of Colussi algorithm;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n) time complexity;</span><br></li><li><span style="line-height: normal;">performs n text character comparisons in the worst case.</span><br></li></ul></div></div>', '2013-04-30 11:12:28', '2013-04-30 11:14:13', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(33, 'Apostolico-Crochemore', '', '<div>The Apostolico-Crochemore uses the kmpNext shift table (see chapter Knuth, Morris and Pratt algorithm) to compute the shifts.</div><div><br></div><div>Let&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">=0 if x is a power of a single character (x=c^m with c in ) and&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;be equal to the position of the first character of x different from x[0] otherwise (<i>x=a^<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">bu for a, b in , u in * and a&nbsp;</i><img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7"><i>&nbsp;b</i>). During each attempt the comparisons are made with pattern positions in the following order:&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">,&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">+1, ... , m-2, m-1, 0, 1, ... ,&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">-1.</div><div>During the searching phase we consider triple of the form (i, j, k) where:&nbsp;</div><div><br><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><ul><li><span style="line-height: normal;">the window is positioned on the text factor y[j .. j+m-1];</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">0&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;k&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;and x[0 .. k-1]=y[j .. j+k-1];</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;"><img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i &lt; m and x[<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;.. i-1]=y[j+<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;.. i+j-1].</span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div><br></div><div>The initial triple is (<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">,0,0).</div><div><br></div><div style="text-align: center;">&nbsp;&nbsp;<img src="data:image/gif;base64,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"></div><div style="text-align: center;"><b>Figure 11.1</b>: At each attempt of the Apostolico-Crochemore algorithm we consider a triple (i,j,k).</div><div><br></div><div>We now explain how to compute the next triple after (i,j,k) has been computed.</div><div>Three cases arise depending on the value of i:</div><div>&nbsp; <span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;"></span></span>i =&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs="></div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>&nbsp;If x[i] = y[i+j] then the next triple is (i+1, j, k).</div><div>&nbsp;If x[i]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[i+j] then the next triple is (, j+1, max{0, k-1}).</div></blockquote><div><img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;<span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span> &lt; i &lt; m</div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>&nbsp;If x[i] = y[i+j] then the next triple is (i+1, j, k).</div><div>&nbsp;If x[i]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[i+j] then two cases arise depending on the value of kmpNext[i]:&nbsp;</div></blockquote><div><ul><ul><ul><li><span style="line-height: normal;">kmpNext[i]<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;: then the next triple is (, i+j-kmpNext[i], max{0, kmpNext[i]})</span></li><li><span style="line-height: normal;">kmpNext[i] &gt;&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">: then the next triple is (kmpNext[i], i+j-kmpNext[i], )</span></li></ul></ul></ul></div><div>&nbsp;<span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span>i =m</div><div>&nbsp;If k &lt;&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;and x[k]=y[j+k] then the next triple is (i, j, k+1).</div><div>&nbsp;Otherwise either k &lt;&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;and x[k]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[j+k], or k=<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">. If k=<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;an occurrence of x is reported. In both cases the next triple is computed in the same manner as in the case where&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">&nbsp;&lt; i &lt; m.</div><div><br></div><div>The preprocessing phase consists in computing the table kmpNext and the integer&nbsp;<img src="data:image/gif;base64,R0lGODlhBwAMALMAAAAAAMrKyr+/vwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAAIALAAAAAAHAAwAAAQVUEgBwKTSZjytxh94VRfXhV7JoVoEADs=">. It can be done in O(m) space and time. The searching phase is in O(n) time complexity and furthermore the Apostolico-Crochemore algorithm performs at most&nbsp;<img src="data:image/gif;base64,R0lGODlhCQAXAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAJABcAAAIhTACmZ7nqHnsoShsxpEj6f1QiSDZWgy7OuXnsRH3JOSoFADs=">n text character comparisons in the worst case.<br></div>', '2013-04-30 11:14:55', '2013-04-30 11:22:53', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(34, 'Not So Naive', '', '&nbsp; &nbsp; During the searching phase of the Not So Naive algorithm the character comparisons are made with the pattern positions in the following order 1, 2, ... , m-2, m-1, 0.<div><br></div><div>&nbsp; &nbsp; For each attempt where the window is positioned on the text factor y[j .. j+m-1]: if x[0]=x[1] and x[1]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[j+1] of if x[0]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;x[1] and x[1]=y[j+1] the pattern is shifted by 2 positions at the end of the attempt and by 1 otherwise.</div><div><br></div><div>&nbsp; &nbsp; Thus the preprocessing phase can be done in constant time and space. The searching phase of the Not So Naive algorithm has a quadratic worst case but it is slightly (by coefficient) sub-linear in the average case.</div><div><br></div><div><br></div><div><b>Main features:</b><br></div><div><b><br></b></div><div><div><ul><li><span style="line-height: normal;"><div style="display: inline !important;">preprocessing phase in constant time and space;</div></span><br></li><li><span style="line-height: normal;"><div style="display: inline !important;">searching phase in O(nm) time complexity;</div></span><br></li><li><span style="line-height: normal;"><div style="display: inline !important;">slightly (by coefficient) sub-linear in the average case.</div></span><br></li></ul></div></div>', '2013-04-30 11:23:21', '2013-04-30 11:24:56', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(35, 'Boyer-Moore', '', 'The Boyer-Moore algorithm is considered as the most efficient string-matching algorithm in usual applications. A simplified version of it or the entire algorithm is often implemented in text editors for the «search» and «substitute» commands.<div><br></div><div>The algorithm scans the characters of the pattern from right to left beginning with the rightmost one. In case of a mismatch (or a complete match of the whole pattern) it uses two precomputed functions to shift the window to the right. These two shift functions are called the good-suffix shift (also called matching shift and the bad-character shift (also called the occurrence shift).</div><div><br></div><div>Assume that a mismatch occurs between the character x[i]=a of the pattern and the character y[i+j]=b of the text during an attempt at position j.</div><div>&nbsp;Then, x[i+1 .. m-1]=y[i+j+1 .. j+m-1]=u and x[i]&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;y[i+j]. The good-suffix shift consists in aligning the segment y[i+j+1 .. j+m-1]=x[i+1 .. m-1] with its rightmost occurrence in x that is preceded by a character different from x[i] (see figure 13.1).</div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;"><b>Figure 13.1.</b> The good-suffix shift, u re-occurs preceded by a character c different from a.</div><div style="text-align: left;">If there exists no such segment, the shift consists in aligning the longest suffix v of y[i+j+1 .. j+m-1] with a matching prefix of x (see figure 13.2).</div><div><br></div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;"><b>Figure 13.2. </b>The good-suffix shift, only a suffix of u re-occurs in x.</div><div><br></div><div>The bad-character shift consists in aligning the text character y[i+j] with its rightmost occurrence in x[0 .. m-2]. (see figure 13.3)</div><div><br></div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;"><b>Figure 13.3. </b>The bad-character shift, a occurs in x.</div><div><br></div><div>If y[i+j] does not occur in the pattern x, no occurrence of x in y can include y[i+j], and the left end of the window is aligned with the character immediately after y[i+j], namely y[i+j+1] (see figure 13.4).</div><div><br></div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,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"><br></div><div style="text-align: center;"><b>Figure 13.4.</b> The bad-character shift, b does not occur in x.</div><div><br></div><div>Note that the bad-character shift can be negative, thus for shifting the window, the Boyer-Moore algorithm applies the maximum between the the good-suffix shift and bad-character shift. More formally the two shift functions are defined as follows.</div><div><br></div><div>The good-suffix shift function is stored in a table bmGs of size m+1.</div><div>Let us define two conditions:&nbsp;</div><div><ul><li><span style="line-height: normal;">Cs(i, s): for each k such that i &lt; k &lt; m, s &nbsp;k or x[k-s]=x[k] and</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">Co(i, s): if s &lt;i then x[i-s]&nbsp;</span><img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIRjI8BmbB8HIxQtqeosYhHjBQAOw==" style="line-height: normal;"><span style="line-height: normal;">&nbsp;x[i]</span><br></li></ul></div><div><span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span></div><div><br></div><div><br></div><div>Then, for 0 &nbsp;i &lt; m: bmGs[i+1]=min{s&gt;0 : Cs(i, s) and Co(i, s) hold}</div><div>&nbsp;and we define bmGs[0] as the length of the period of x. The computation of the table bmGs use a table suff defined as follows: for 1&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i &lt; m, suff[i]=max{k : x[i-k+1 .. i]=x[m-k .. m-1]}</div><div><br></div><div>The bad-character shift function is stored in a table bmBc of size . For c in : bmBc[c] = min{i : 1&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI95oAGcXoPN0bWuxVFHUwA7">&nbsp;i &lt;m-1 and x[m-1-i]=c} if c occurs in x, m otherwise.</div><div><br></div><div>Tables bmBc and bmGs can be precomputed in time O(m+) before the searching phase and require an extra-space in O(m+). The searching phase time complexity is quadratic but at most 3n text character comparisons are performed when searching for a non periodic pattern. On large alphabets (relatively to the length of the pattern) the algorithm is extremely fast. When searching for am-1b in bn the algorithm makes only O(n / m) comparisons, which is the absolute minimum for any string-matching algorithm in the model where the pattern only is preprocessed.</div>', '2013-04-30 11:25:56', '2013-04-30 11:30:31', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(36, 'Turbo-BM', '', '<div>&nbsp; &nbsp; The Turbo-BM algorithm is an amelioration of the Boyer-Moore algorithm. It needs no extra preprocessing and requires only a constant extra space with respect to the original Boyer-Moore algorithm. It consists in remembering the factor of the text that matched a suffix of the pattern during the last attempt (and only if a good-suffix shift was performed).</div><div>This technique presents two advantages: <span class="Apple-tab-span" style="white-space:pre"><span style="white-space: normal;">	</span></span><br></div><div><ul><li><span style="line-height: normal;">it is possible to jump over this factor;</span><span style="line-height: normal;">&nbsp;</span></li><li><span style="line-height: normal;">it can enable to perform a turbo-shift.</span></li></ul></div><div>&nbsp; &nbsp; A turbo-shift can occur if during the current attempt the suffix of the pattern that matches the text is shorter than the one remembered from the preceding attempt. In this case let us call u the remembered factor and v the suffix matched during the current attempt such that uzv is a suffix of x. Let a and b be the characters that cause the mismatch during the current attempt in the pattern and the text respectively. Then av is a suffix of x, and thus of u since |v| &lt; |u|. The two characters a and b occur at distance p in the text, and the suffix of x of length |uzv| has a period of length p=|zv| since u is a border of uzv, thus it cannot overlap both occurrences of two different characters a and b, at distance &nbsp;p, in the text. The smallest shift possible has length |u|-|v|, which we call a turbo-shift (see figure 14.1).</div><div><br></div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,R0lGODlhCwKpALMAAAAAAAgICBQUFCEhITU1NUpKSlpaWouLi62trcHBwc7OztbW1t7e3ufn5+/v7////yH5BAEAAA8ALAAAAAALAqkAAAT+8MlJq7046827/2AojmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcEgsGo/IpHLJbDqf0Kh0Sq1ar9isVpcwABKs7vcyMEwSBcNgy26731GFgpQYh+2VskQhMCTWD3Jwg4SFhjQIYCN1iiuMG48TiYeUlZaXGgwDjSGRjngYnpqcmKWmp1p/AAYGDA9drbCKsAwGCK9frKQPtbYZvQy3uLITrLesq7eqrK6ozs/QTJ7DEqtnq164A64FBRQGBa7gGN4P47itD3jdEp7T0fDx8jvTkdbt1sp4erzrZhXMJJSr8+/eA3bU8O2ax7ChwxT17Bh0t65ctmJfEmicU2dAAQT+DhRW+3dwIJ53D1OqXKnh0ZyEE09WlHCRJoBu3f4h6HbPHkmEFMG8ZEm0qMpHJhXFbOSJHwIA3wBREGYOKsyfSa+BKWe0q1d4SEUS1HrtX51mD/rgo1qMpACR6rDCpcb1q927mHamo8nKy8dXXgJ2QdC3Qi81C/sKDpzo5rEBZQhja6YXLd7LmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPrhkY4sIzAJHcLH94WADYbyI4TX047OasevbGxZU49tfHr2LNr3869u/frUquLPx09mQ7nwcerRx3d2G8vytfLd+0+BuHp8/Pr38+/v///AAb+KOCABBZo4IEIJqjgggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YfRfCfiiCSWaOKJKKao4oostujiizDGKOOMNNaIYnpKWFUbAAv06OOPQAYp5JAL8EjkkEYeqeSSTAbJwALPaQEAAlRWaeWVVfL4ZJNcdukklDi6EGUTOtKWpJdentmkmmi2ueSTY2IxJZZ0Wqmlm3gqCWeYLcS5RJmzsZknkYIqWeigg+65xZx11nknopD2qOgMfuZ426GR9ogpkplmOmkWjFZZgAAENPpop3l+GkOlSQAq26aRwhqkrKi+CeaidA5QqqMLbFmrm6rCwCoSrsZG66DH+pjsr0L+BmtFqFQeAMABpvbKLLC3UsrnCrWgNckIxcK2rJvjjnutj85WAe1OAVDLq6/ncplun9uqUMAfzfAjQrivmYumoAcY4O6siHaRQI9UJpotqFgSQMABadB5apsGI4yAwsOykLEKrGwzEgn8uuZvmkDCsgACDhM8aKmbQDmypAvLiaUAfezkrp3W4snywV5gXC/HP6OAcjlPLdRByK29zKWaBBigrNNAKg1my0X6jOuVjkmG5cRodnxw1anGLGzQJ0RS076Xxqvpj3VcvIC0bv8o9QEp90iA1VJe6YW7BazLtZd032033u9RSkBID+iLtm1SM3lmzz1CHjWiT7mdwAH+hMtsZd+iCrB1zm5W3uPlmY9NqUlkY4A0a40v+fgAPpYBtdyIGkDA17PjOe8U0I5aZc1Yg96m7bgjuvsKGwOtxuoaMK9a64b+KC3CqwhO+6AHtEyY8WI/q/ecBAQgsfBoZn/w9qW/kDwKCuRb1+I7qg22j31R27TKgyoG6fFRrIvTR+OD1/D6sr/uiSl1JfDcAxAgAKN5wHnWkV+55Ocl/kFhXY3KEvkoSCQLomB9J/DDfU4AQdRA70gT5GCTPOgEDGbwKRtU4ZdAGEIEksABGkGcCUp4mhMS6l8yZBILyfTCAAbxSEMsAQ2DwEPT+JBTJDsiEg1IBRdm8G9ShNn+EpVowx80sTRPFFIKs9gsKvKuiJ8TIBmttUUStNEH2FCMHOdIxzra8Y54zKMe98jHPvqxLwCADM0GSchCGvKQiAQAIhcpAEUy8pGQjOQhIQOZP1rykn8MpCQFAJlADmCToAwlISkpO0zy8QmmTKUqV8nKVs6RlLCMpSxnOcsA0JKWtrylLnfJy1s2zZXA9GMvYZnLYRrzmLIMZh3xA6JmOvOZ0IymNKdJzWpa85rYzKY2t8nNbnrzm+AMpzjHSc5ymvOc6EynOomCjC4axTi+WOdq0EOa9sRTnqGxJzNJQ098esZGAA2oQFMUHn9upp+nQahBQaPP0Ch0oaapz2f+JArRilr0ohjNqEY3ytGOevSjIA2pSEdaBCrxhaQdBUdA3odSi4KDK2ppKUYPENO4yBSjnpjSTS9qO8QhoKA7NShQdBrUisYRqEXFJwMMcgWTmsOdSb3N2a6g0nSwNKrMEcNQqIqQtEAVq7HRSAK2agWakoSpYE1nTveZVnL2VAI/bas8h8pWuYrzqHZd51K/mtdsTrWv59QqYNUpVrIO9rCITaxiF8vYxgYVGQ6lqGMv8VDPVHayb2hoai6LWSwMYKCgDa1or9NZN2gWNZwtrRZSqxnWqvYNkAVNX+r62tra9ra4za1ud8vb3vr2t8ANrnCHS9ziGve4yE2ucpf+q5neKPO5wCQAMqdL3epat5fFvK52t0uzY3Z3u+CFJXHiCN3yqpKUokyvetfL3kV2MrzwpW4AbLnJAcxXkO3N7yg/O15UsGKNAP7XFiCDRitBJsBi7O8p/ovgBhtqwAMocJUO7GBlKdgUDK6whuUGYQlTicIa/uJqRLza3G04xB32MIgrTGLr+NfEJ3Zwi4tAYBXDbsMzVkktlOGHEuTYChmOMYtTLOEVyzg0tYhLF676wBc7uGI9otaQZ+BU2p6gxnpLwwFu9uEb5wnKCUPUjx1SjpvwwsoZGDMVggzgnfWoDFNeFTx7HAMsR6sbCAjclYzcJjdLLk9qZsgtFID+VnA5ucFe0xSM1xhoC3ShHXz1gJ1/CsCnVLrLtUPM2sQ8GpTArxRsXmPgojylOBduBnaWlrv2tmcv42nUg+O0aN4a6UZHIdRkFJ3LUDyDBKAZBXbmHJWEbWBXh67UCyCdrC0bDoQwuckLXnQWifdmgZnaBbVQxK9LEGzPUUkAeC527W4XuViBBg1+KMwOD41g21EP12S0NQXS0BekssDOXojWTXY1YWO3yXwnk7aAhyNvVApcior56cGPWPBXgGGp9r53hDeXE7pd+qf+HiC829TwznScCRsXcryJXGA+I/jjm0G5EkIucimq3AaTLqLJA/xyzNT8CCxveRBvjupMiRc54zS/MKgXrnMZ8lwGMX/hzAF8dLs0fQg5LzoHn/6CpGdw6YwWOiaiLnUJkhyNWB85wUdL9rKb/exoT7vaS8Tctrv97XCPezcjAAA7"><br></div><div style="text-align: center;"><b>Figure 14.1. </b>A turbo-shift can apply when |v|&lt;|u|.</div><div><br></div><div>&nbsp; &nbsp; Still in the case where |v|&lt;|u| if the length of the bad-character shift is larger than the length of the good-suffix shift and the length of the turbo-shift then the length of the actual shift must be greater or equal to |u|+1. Indeed, in this case the two characters c and d are different since we assumed that the previous shift was a good-suffix shift. (see figure 14.2)</div><div><br></div><div><br></div><div style="text-align: center;"><img src="data:image/gif;base64,R0lGODlhAgKBALMAAAAAAAgICBQUFCEhITExMUZGRlpaWouLi62trcHBwc7OztbW1t7e3ufn5+/v7////yH5BAEAAA8ALAAAAAACAoEAAAT+8MlJq7046827/2AojmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpuXCQMgwUqvLwPDJFEwDM74vP6sUJASb22BFXESCgIGCXcPfXuOj5BTCGwjgJQrlhuZE5ORnp+gQgwDlyGbmIMYp6Oloa6vsC2KAAYGDA9ptrmUuQwGCLhrta0Pvr8ZxgzAwbsTtcC1tMCztbex19jZH6fMErRztGrBA7cFBRQGBbfpGOcP7MG2D4PmEqfc2vn6+dyb3/bfpg0qVIyenArVJLgDdPDfg3rdABLbR7Hip36BHN6j506cszX+CUL6ATSgAAIHEr0dfLhwED6LMGPmyeQnokaXHCV41AnAnLmDCMz987cS4kY2NWUqXRomU0tKNy+dIogAALpFFJa9s2qz6FNwbNwxHUsWi9OUDMGCOwjI2gNEALU6Wykg5TyvdruJLcu375Og8nTWUmMSl5qEaRAMrmDMzsTBiA9P6gltQBzF4awBduu3s+fPoEOLHk26tOnTqFOrXs26tevXsGPLnk27tu3buHPr3k1FsVwXinkL5x1NmozitYYrh418pQ3Faowvn14aAADLdSBr3869u/fuBQZY30u9vF/L1i1/X8++Pfrrzs3L7ws93O8YzefrH43Z4YvDx+z+J+CABBZo4IEIJqjgggw26OCDEEYo4YQUVmjhhRhmqOGGHHbo4YcghijiiCSWaOKJBban4oostujiizDGKCOLlg0gwI045pijZQHU6OOPQAYp5JBE/pjdjEgmaYdlOjaJI49FRinllEEeqWR39wERzpVcdunll2Cud52NTjopHpNlpqnmmmwK4GOYcHZ3XZs3oocmnXjmqeObcSZXBFcUAoDAoIQWaiihACyg6KKMNuroo5BGGikDC/iZhaCHZlpoopJ26umnkVqKX3xBADohpppqyimorLb6KKWiXoFqqoeu6uqtt8b6H6laWjgrrZviKiyrsPJKxa9BCUBAqrb+DutsqMayoGuvFSILbFXPZvtqpdFKYe0Ay6qq7biNTtuCuT6YKqG1wDZLrrPFboHsAQAcwOy776K7gr4g+OJWJyOoGyG7tLqLL67xaoFsAQHYK+7B2vKbgsQeFKCINQSJIDCE1qZjwAEOB/tsGgkoOuizCV96KAEEHFBHpgbnuujJ2VJ8gs0c1EKOSiRs/OCvLpt0AMu1ZmsSKZXGTCy38h564y8FhIyo0QgMoKgaEXerAs4bIECAO1VN1IHPDv5aEqImGao0qzqXvMDan6aMBbKUYVb0szovCjeoXJPQdwab7KSxr4XS67AaUg+6t6dDF7Co4/AyrbChiA9aAN3+2Tb+eNY0/I2BAQSg9EDGg1db6OWEon63s1UhoGgCB6Asucqno1qAAKsP2/qisdes9cS/ewBPWj0TnjrugwpgTu7Cgu62AdnKLauhtxOKCPO4gr4o9JzP4PnnOpM9tvGDqjEovQWEK7KzByCtWPSzz005pgQEAHPmVi/wfvfHBd+BAhgjTwjEx6Bf+eRjX8Ne9gajLelZYWE+eRjeGDiu74HAghXA3QMQIACxeYCACyLYvSAWOQz+6VoKJKGrTNgBFuokAb45AQgVJEIJqvBWDqxCDe93w2G5cAM/dEBIRGeCGSZohynsYadyeCwUqk2JzfOfCX7IAiMiCIlPhGL+q5g4BSyuT4tsk2IJqLgCKx7Ii1MDI6i46C0nflGNniIj+IxgRgOhUXFwjFv8pudGPObxU3K8QCBRYJ1CGvKQiEykIhfJyEY68pGQjKQkJ0nJSlrykpjMpCY3yclOevKTmxQjikZJylKa8pSoTKUqV8nKVrrylbCMpSxnScta2vKWuMylLnfJy1768pfADKYwh0nMYhrzmMhMpjKXycxmOvOZ0IymNKdJzWpa85rY9Bsot8nNbnrzm+AMpzjHScna1FEJz+ijZf7IznGdM51uXGc75zmsc47GnkiApxPlSc9+tuqdv1Bn/vxJUE/hMzQHNYI+UcjPgjr0UQDtY9X+BvrQiurNnFtY6LUaatGKRlRTt1PfoDjaUYcm9DMnJYJGgUXSkhL0o5oCl6Fa6tJ+prQzNxXCSmlF05rOE6YwSxuheupTdubUE76YRiJKcFQg7DRVRC1qHoFqKHoFdKgUlSo9m/oIX9wlDQL8AFd9sNOgHSqqeeSeouz1UKoqpg6qKxRa1Ugy3rnOpGRxR0+KkaUPZvSqp4ta6+SaVXoebVFxaKsI9GnWoYl0pIWd59Hclli8jgUYCvBP8bSg0eUhYGgzjWw786YoWig2BPo8m+KEilWHtq20an0pX15Suiws1HBQFS07NbcAet21oDDFLWYSN1GH8ta3pyUL6FD+IsoKjLUHC41rpuYKxt0lzaOLvWpcpdvagloXa8lVSjoYAJGwivWv1JtV4qirRe0pKg69A252j2c9zxLWtQSg7MfCKxM6JGIxRURvocx3PtYWt6DpMFk4+NvCqxIYfY89MEETrL8FW3Y2z+WBRtPxk7Pqlp2QqVps/QnUAzbOww8NcWXlS5sM7+CpMf2wVtXoVpbKeMZadLFSdJwDGE/3xjhWYo15CuQg35DHMUHyDXyMYiO3c8i5dfKTMcpZwDK0yFI+GJRjnOU/KtkiX64Bk0Pb5anOV6BlhmOYKbJm71l5o1hOs7a2/GM5g7HN+iCnnvfM5z77+c+AlmQ2B00b6EIb+tCITrSiF83oRjv60ZCOtKQnTWkVRAAAADs="><br></div><div style="text-align: center;"><b>Figure 14.2.&nbsp;</b>c&nbsp;<img src="data:image/gif;base64,R0lGODlhCgAKAIAAAAAAAP///yH5BAEAAAEALAAAAAAKAAoAAAIQjI8ZoMYHoozq1Tolsom3VgA7">&nbsp;d so they cannot be aligned with the same character in v.</div><div><br></div><div>&nbsp; &nbsp; Then a shift greater than the turbo-shift but smaller than |u|+1 would align c and d with a same character in v. Thus if this case the length of the actual shift must be at least equal to |u|+1.</div><div><br></div><div>&nbsp; &nbsp; The preprocessing phase can be performed in O(m+<img src="data:image/gif;base64,R0lGODlhCAAIAIAAAAAAAL+/vyH5BAEAAAEALAAAAAAIAAgAAAIOTIB5tgb8mpuQyigPYqEAOw==">) time and space complexity. The searching phase is in O(n) time complexity. The number of text character comparisons performed by the Turbo-BM algorithm is bounded by 2n.</div><div><br></div><div><br></div><div><b>Main features:</b></div><div><br></div><div><div><ul><li><span style="line-height: normal;">variant of the Boyer-Moore;</span><br></li><li><span style="line-height: normal;">no extra preprocessing needed with respect to the Boyer-Moore algorithm;</span><br></li><li><span style="line-height: normal;">constant extra space needed with respect to the Boyer-Moore algorithm;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m+) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n) time complexity;</span><br></li><li><span style="line-height: normal;">2n text character comparisons in the worst case.</span><br></li></ul></div></div>', '2013-04-30 11:30:41', '2013-04-30 11:34:41', NULL, 'fuf:D4,sWBu^eZn#Tfxo__z+NH}UV%RZZU3t;Pz ,^W#3d/`a#Dz"n\'2&fhUm,4', 1),
	(38, 'Apostolico-Giancarlo', '', '\n<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">The<span class="Apple-converted-space">&nbsp;</span><a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a><span class="Apple-converted-space">&nbsp;</span>algorithm is difficult to analyze because after each attempt it forgets all the characters it has already matched. Apostolico and Giancarlo designed an algorithm which remembers the length of the longest suffix of the pattern ending at the right position of the window at the end of each attempt. These information are stored in a table<span class="Apple-converted-space">&nbsp;</span><em>skip</em>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">Let us assume that during an attempt at a position less than<span class="Apple-converted-space">&nbsp;</span><i>j</i><span class="Apple-converted-space">&nbsp;</span>the algorithm has matched a suffix of<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>of length<span class="Apple-converted-space">&nbsp;</span><i>k</i><span class="Apple-converted-space">&nbsp;</span>at position<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>i</i>+<i>j</i></span><span class="Apple-converted-space">&nbsp;</span>with<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;">0 &lt;<span class="Apple-converted-space">&nbsp;</span><i>i</i><span class="Apple-converted-space">&nbsp;</span>&lt;<span class="Apple-converted-space">&nbsp;</span><i>m</i></span><span class="Apple-converted-space">&nbsp;</span>then<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>skip</em>[<i>i</i>+<i>j</i>]</span><span class="Apple-converted-space">&nbsp;</span>is equal to<span class="Apple-converted-space">&nbsp;</span><i>k</i>. Let<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>suff</em>[<i>i</i>]</span>, for<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;">0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i><span class="Apple-converted-space">&nbsp;</span>&lt;<span class="Apple-converted-space">&nbsp;</span><i>m</i></span><span class="Apple-converted-space">&nbsp;</span>be equal to the length of the longest suffix of<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>ending at the position<span class="Apple-converted-space">&nbsp;</span><i>i</i><span class="Apple-converted-space">&nbsp;</span>in<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>(see chapter<span class="Apple-converted-space">&nbsp;</span><a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a><span class="Apple-converted-space">&nbsp;</span>algorithm).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">During the attempt at position<span class="Apple-converted-space">&nbsp;</span><i>j</i>, if the algorithm compares successfully the factor of the text<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>y</i>[<i>i</i>+<i>j</i>+1 ..<span class="Apple-converted-space">&nbsp;</span><i>j</i>+<i>m</i>-1]</span></p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"><dt><span style="font-weight: normal;">then four cases arise:</span></dt><dd style="font-weight: normal; margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><p>Case 1:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>k</i><span class="Apple-converted-space">&nbsp;</span>&gt;<span class="Apple-converted-space">&nbsp;</span><em>suff</em>[<i>i</i>]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>suff</em>[<i>i</i>]=<i>i</i>+1</span>. It means that an occurrence of<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>is found at position<span class="Apple-converted-space">&nbsp;</span><i>j</i><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>skip</em>[j+m-1]</span><span class="Apple-converted-space">&nbsp;</span>is set to<span class="Apple-converted-space">&nbsp;</span><i>m</i><span class="Apple-converted-space">&nbsp;</span>(see figure 15.1). A shift of length<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>per</em>(<i>x</i>)</span><span class="Apple-converted-space">&nbsp;</span>is performed.</p><p align="center"><img alt="ag1" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ag1.gif"></p><p style="margin: 2px 6px 6px 12px;" align="center"><b>Figure 15.1</b>, an occurrence of<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>is found.</p></td></tr></tbody></table></dd><dd style="font-weight: normal; margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">Case 2:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>k</i><span class="Apple-converted-space">&nbsp;</span>&gt;<span class="Apple-converted-space">&nbsp;</span><em>suff</em>[<i>i</i>]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>suff</em>[<i>i</i>]&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i></span>. It means that a mismatch occurs between characters<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;">x[<i>i</i>-<em>suff</em>[<i>i</i>]]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;">y[<i>i</i>+<i>j</i>-<em>suff</em>[<i>i</i>]]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>skip</em>[<i>j</i>+<i>m</i>-1]</span><span class="Apple-converted-space">&nbsp;</span>is set to<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>m</i>-1-<i>i</i>+<em>suff</em>[i]</span><span class="Apple-converted-space">&nbsp;</span>(see figure 15.2). A shift is performed using<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>bmBc</em>[y[<i>i</i>+<i>j</i>-<em>suff</em>[<i>i</i>]]]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>bmGs</em>[<i>i</i>-<em>suff</em>[<i>i</i>]+1]</span>.<p style="margin: 2px 6px 6px 12px;" align="center"><img alt="ag2" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ag2.gif"></p><p style="margin: 2px 6px 6px 12px;" align="center"><b>Figure 15.2</b>, a mismatch occurs between<span class="Apple-converted-space">&nbsp;</span><i>y</i>[<i>i</i>+<i>j</i>-<em>suff</em>[<i>i</i>]] and<span class="Apple-converted-space">&nbsp;</span><i>x</i>[<i>i</i>-<em>suff</em>[<i>i</i>]].</p></td></tr></tbody></table></dd><dd style="font-weight: normal; margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">Case 3:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>k</i><span class="Apple-converted-space">&nbsp;</span>&lt;<span class="Apple-converted-space">&nbsp;</span><em>suff</em>[<i>i</i>]</span>. It means that a mismatch occurs between characters<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>x</i>[<i>i</i>-<i>k</i>]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>y</i>[<i>i</i>+<i>j</i>-<i>k</i>]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>skip</em>[<i>j</i>+<i>m</i>-1]</span><span class="Apple-converted-space">&nbsp;</span>is set to<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>m</i>-1-<i>i</i>+<i>k</i></span><span class="Apple-converted-space">&nbsp;</span>(see figure 15.3). A shift is performed using<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>bmBc</em>[<i>y</i>[<i>i</i>+<i>j</i>-<i>k</i>]]</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>bmGs</em>[<i>i</i>-<i>k</i>+1]</span>.<p style="margin: 2px 6px 6px 12px;" align="center"><img alt="ag3" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ag3.gif"></p><p style="margin: 2px 6px 6px 12px;" align="center"><b>Figure 15.3</b>, a mismatch occurs between<span class="Apple-converted-space">&nbsp;</span><i>y</i>[<i>i</i>+<i>j</i>-<i>k</i>] and<span class="Apple-converted-space">&nbsp;</span><i>x</i>[<i>i</i>-<i>k</i>].</p></td></tr></tbody></table></dd><dd style="font-weight: normal; margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">Case 4:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>k</i>=<em>suff</em>[<i>i</i>]</span>. This is the only case where a "jump" has to be done over the text factor<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>y</i>[<i>i</i>+<i>j</i>-<i>k</i>+1 ..<span class="Apple-converted-space">&nbsp;</span><i>i</i>+<i>j</i>]</span><span class="Apple-converted-space">&nbsp;</span>in order to resume the comparisons between the characters<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>y</i>[<i>i</i>+<i>j</i>-<i>k</i>]</span><span class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><i>x</i>[<i>i</i>-<i>k</i>]</span><span class="Apple-converted-space">&nbsp;</span>(see figure 15.4).<p style="margin: 2px 6px 6px 12px;" align="center"><img alt="ag4" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ag4.gif"></p><p style="margin: 2px 6px 6px 12px;" align="center"><b>Figure 15.4</b>,<span class="Apple-converted-space">&nbsp;</span><i>a</i>&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;<i>b</i>.</p></td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">In each case the only information which is needed is the length of the longest suffix of<span class="Apple-converted-space">&nbsp;</span><i>x</i><span class="Apple-converted-space">&nbsp;</span>ending at position<span class="Apple-converted-space">&nbsp;</span><i>i</i><span class="Apple-converted-space">&nbsp;</span>on<span class="Apple-converted-space">&nbsp;</span><i>x</i>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"><dt>The Apostolico-Giancarlo algorithm use two data structures:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">a table<span class="Apple-converted-space">&nbsp;</span><em>skip</em><span class="Apple-converted-space">&nbsp;</span>which is updated at the end of each attempt<span class="Apple-converted-space">&nbsp;</span><i>j</i><span class="Apple-converted-space">&nbsp;</span>in the following way:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><em>skip</em>[<i>j</i>+<i>m</i>-1]=max{ k&nbsp;<big>:</big>&nbsp;<i>x</i>[<i>m</i>-<i>k</i><span class="Apple-converted-space">&nbsp;</span>.. m-1]=y[<i>j</i>+<i>m</i>-<i>k</i><span class="Apple-converted-space">&nbsp;</span>..<span class="Apple-converted-space">&nbsp;</span><i>j</i>+<i>m</i>-1]}</span></td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">the table<span class="Apple-converted-space">&nbsp;</span><em>suff</em><span class="Apple-converted-space">&nbsp;</span>used during the computation of the table<span class="Apple-converted-space">&nbsp;</span><em>bmGs</em>:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;">for 1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i><span class="Apple-converted-space">&nbsp;</span>&lt;<span class="Apple-converted-space">&nbsp;</span><i>m</i></span><span style="white-space: nowrap;"><em>suff</em>[<i>i</i>]=max{<i>k</i>&nbsp;<big>:</big>&nbsp;<i>x</i>[<i>i</i>-<i>k</i>+1 ..<span class="Apple-converted-space">&nbsp;</span><i>i</i>]=<i>x</i>[<i>m</i>-<i>k</i><span class="Apple-converted-space">&nbsp;</span>..<span class="Apple-converted-space">&nbsp;</span><i>m</i>-1]}</span></td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">The complexity in space and time of the preprocessing phase of the Apostolico-Giancarlo algorithm is the same than for the Boyer-Moore algorithm:<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">During the search phase only the last<span class="Apple-converted-space">&nbsp;</span><i>m</i><span class="Apple-converted-space">&nbsp;</span>informations of the table<span class="Apple-converted-space">&nbsp;</span><em>skip</em><span class="Apple-converted-space">&nbsp;</span>are needed at each attempt so the size of the table<span class="Apple-converted-space">&nbsp;</span><em>skip</em><span class="Apple-converted-space">&nbsp;</span>can be reduced to<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>)</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;">The Apostolico-Giancarlo algorithm performs in the worst case at most<span class="Apple-converted-space">&nbsp;</span><span style="white-space: nowrap;"><img alt="3/2" align="MIDDLE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/troisdemi.gif"><i>n</i></span><span class="Apple-converted-space">&nbsp;</span>text character comparisons.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"><strong>Main features:</strong><strong><br></strong></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;"><ul><li><span style="line-height: normal;">variant of the Boyer-Moore algorithm;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m+) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(n) time complexity;</span><br></li><li><span style="line-height: normal;">n comparisons in the worst case;</span><br></li></ul></p>', '2013-05-01 06:47:30', '2013-05-01 09:07:50', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(40, 'Reverse Colussi', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The character comparisons are done using a specific order given by a table&nbsp;<i>h</i>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>For each integer&nbsp;<i>i</i>&nbsp;such that&nbsp;<span style="white-space: nowrap;">0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;i&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i></span>&nbsp;we define two disjoint sets:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><big><em>Pos</em></big>(<i>i</i>)={<i>k</i>&nbsp;<big>:</big>&nbsp; 0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>k</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;and&nbsp;<i>x</i>[<i>i</i>] =&nbsp;<i>x</i>[<i>i</i>-<i>k</i>]}</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><big><em>Neg</em></big>(<i>i</i>)={<i>k</i>&nbsp;<big>:</big>&nbsp; 0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>k</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;and&nbsp;<i>x</i>[<i>i</i>]&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;<i>x</i>[<i>i</i>-<i>k</i>]}</td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For&nbsp;<span style="white-space: nowrap;">1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>k</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i></span>, let&nbsp;<span style="white-space: nowrap;"><em>hmin</em>[<i>k</i>]</span>&nbsp;be the minimum integer&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;such that&nbsp;<span style="white-space: nowrap;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;<i>k</i>-1</span>&nbsp;and&nbsp;<span style="white-space: nowrap;"><i>k</i>&nbsp;not in&nbsp;<em>Neg</em>(<i>i</i>)</span>&nbsp;for all&nbsp;<i>i</i>&nbsp;such that&nbsp;<span style="white-space: nowrap;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;&lt;&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>-1</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For&nbsp;<span style="white-space: nowrap;">0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>-1</span>, let&nbsp;<span style="white-space: nowrap;"><em>kmin</em>[<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">]</span>&nbsp;be the minimum integer&nbsp;<i>k</i>&nbsp;such that&nbsp;<span style="white-space: nowrap;"><em>hmin</em>[<i>k</i>]=<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;<i>k</i></span>&nbsp;if any such&nbsp;<i>k</i>&nbsp;exists and&nbsp;<span style="white-space: nowrap;"><em>kmin</em>[<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">]=0</span>&nbsp;otherwise.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For&nbsp;<span style="white-space: nowrap;">0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>-1</span>, let&nbsp;<span style="white-space: nowrap;"><em>rmin</em>[<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">]</span>&nbsp;be the minimum integer&nbsp;<i>k</i>&nbsp;such that&nbsp;<span style="white-space: nowrap;"><i>r</i>&nbsp;&gt;&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></span>&nbsp;and&nbsp;<span style="white-space: nowrap;"><em>hmin</em>[<i>r</i>]=<i>r</i>-1</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The value of&nbsp;<span style="white-space: nowrap;"><i>h</i>[0]</span>&nbsp;is set to&nbsp;<span style="white-space: nowrap;"><i>m</i>-1</span>. After that we choose in increasing order of&nbsp;<span style="white-space: nowrap;"><em>kmin</em>[<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">]</span>, all the indexes&nbsp;<span style="white-space: nowrap;"><i>h</i>[1], ... ,&nbsp;<i>h</i>[<i>d</i>]</span>&nbsp;such that&nbsp;<span style="white-space: nowrap;"><em>kmin</em>[<i>h</i>[<i>i</i>]]&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;0</span>&nbsp;and we set&nbsp;<span style="white-space: nowrap;"><em>rcGs</em>[<i>i</i>]</span>&nbsp;to&nbsp;<span style="white-space: nowrap;"><em>kmin</em>[<i>h</i>[<i>i</i>]]</span>&nbsp;for&nbsp;<span style="white-space: nowrap;">1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>d</i></span>. Then we choose the indexes&nbsp;<span style="white-space: nowrap;"><i>h</i>[<i>d</i>+1], ... ,&nbsp;<i>h</i>[<i>m</i>-1]</span>&nbsp;in increasing order and we set&nbsp;<span style="white-space: nowrap;"><em>rcGs</em>[<i>i</i>]</span>&nbsp;to&nbsp;<span style="white-space: nowrap;"><em>rmin</em>[<i>h</i>[<i>i</i>]]</span>&nbsp;for&nbsp;<span style="white-space: nowrap;"><i>d</i>&nbsp;&lt;&nbsp;<i>i</i>&nbsp;&lt;&nbsp;<i>m</i></span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The value of&nbsp;<span style="white-space: nowrap;"><em>rcGs</em>[<i>m</i>]</span>&nbsp;is set to the period of&nbsp;<i>x</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The table&nbsp;<em>rcBc</em>&nbsp;is defined as follows:&nbsp;<em>rcBc</em>[<i>a</i>,&nbsp;<i>s</i>]=<em>min</em>{<i>k</i>&nbsp;<big>:</big>&nbsp; (<i>k</i>=<i>m</i>&nbsp;or&nbsp;<i>x</i>[<i>m</i>-<i>k</i>-1]=<i>a</i>) and (<i>k</i>&nbsp;&gt;&nbsp;<i>m</i>-<i>s</i>-1 or&nbsp;<i>x</i>[<i>m</i>-<i>k</i>-<i>s</i>-1]=<i>x</i>[<i>m</i>-<i>s</i>-1])} To compute the table&nbsp;<em>rcBc</em>&nbsp;we define: for each&nbsp;<span style="white-space: nowrap;">c in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"></span>,&nbsp;<span style="white-space: nowrap;"><em>locc</em>[<i>c</i>]</span>&nbsp;is the index of the rightmost occurrence of&nbsp;<i>c</i>&nbsp;in&nbsp;<span style="white-space: nowrap;"><i>x</i>[0 ..&nbsp;<i>m</i>-2]</span>&nbsp;(<span style="white-space: nowrap;"><em>locc</em>[<i>c</i>]</span>&nbsp;is set to&nbsp;<span style="white-space: nowrap;">-1</span>&nbsp;if&nbsp;<i>c</i>&nbsp;does not occur in&nbsp;<span style="white-space: nowrap;"><i>x</i>[0 ..&nbsp;<i>m</i>-2])</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">A table&nbsp;<em>link</em>&nbsp;is used to link downward all the occurrences of each pattern character.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase can be performed in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i><sup>2</sup>)</span>&nbsp;time and&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;space complexity. The searching phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>n</i>)</span>&nbsp;time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"></font></p><p align="justify" style="margin: 2px 6px 6px 12px;"></p><ul><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">refinement of the Boyer-Moore algorithm;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">partitions the set of pattern positions into two disjoint subsets;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">preprocessing phase in O(<i style="white-space: nowrap;">m</i><sup style="font-size: 12px; white-space: nowrap;">2</sup>) time and O(<i style="white-space: nowrap;">m</i><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="white-space: nowrap;">) space;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">searching phase in O(n) time complexity;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">2n text character comparisons in the worst case.</span><br></font></li></ul><div><font color="#000000" face="Times New Roman" size="3"><br></font></div><div><font color="#000000" face="Times New Roman" size="3"><b>Example:</b></font></div><div><p style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><img alt="Reverse Colussi algorithm tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/rctab1.png"><br clear="all"><span style="white-space: nowrap;">Tables used by Reverse Colussi algorithm</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="white-space: nowrap;">Searching phase</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1 (<em>rcBc</em>[A][8])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>rcGs</em>[2])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="6" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="13">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>rcGs</em>[2])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td bgcolor="white">8</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>rcGs</em>[9])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>rcGs</em>[2])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="21" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="2">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 5 (<em>rcBc</em>[A][2])</p><p>The Reverse Colussi algorithm performs 16 character comparisons on the example.</p></p></div><p></p><p></p>', '2013-05-01 09:08:47', '2013-05-01 09:14:21', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(41, 'Horspool', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The bad-character shift used in the Boyer-Moore algorithm (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm) is not very efficient for small alphabets, but when the alphabet is large compared with the length of the pattern, as it is often the case with the ASCII table and ordinary searches made under a text editor, it becomes very useful.<br>Using it alone produces a very efficient algorithm in practice. Horspool proposed to use only the bad-character shift of the rightmost character of the window to compute the shifts in the Boyer-Moore algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;time and&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase has a quadratic worst case but it can be proved that the average number of comparisons for one text character is between&nbsp;<span style="white-space: nowrap;">1/<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></span>&nbsp;and&nbsp;<span style="white-space: nowrap;">2/(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">+1)</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"></font></p><p align="justify" style="margin: 2px 6px 6px 12px;"></p><ul><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">simplification of the Boyer-Moore algorithm;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">easy to implement;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">preprocessing phase in&nbsp;<big style="white-space: nowrap;"><i><b>O</b></i></big><span style="white-space: nowrap;">(</span><i style="white-space: nowrap;">m</i><span style="white-space: nowrap;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="white-space: nowrap;"><span style="white-space: nowrap;">)</span>&nbsp;time and&nbsp;<big style="white-space: nowrap;"><i><b>O</b></i></big><span style="white-space: nowrap;">(</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="white-space: nowrap;"><span style="white-space: nowrap;">)</span>&nbsp;space complexity;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">searching phase in O(mn) time complexity;</span><br></font></li><li><font color="#000000" face="Times New Roman" size="3"><span style="line-height: normal;">the average number of comparisons for one text character is between 1/ and 2/(+1).</span></font></li></ul><div><font color="#000000" face="Times New Roman" size="3"><span style="line-height: 20px;"><br></span></font></div><div><font color="#000000" face="Times New Roman" size="3"><span style="line-height: 20px;"><b>Example:</b></span></font></div><div><p style="margin: 2px 6px 6px 12px; text-align: start;"><font color="#000000" face="Times New Roman" size="3">Preprocessing phase</font></p><p align="center" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><img alt="Horspool algorithm bmBc table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hotab1.png"><br clear="all"><span style="white-space: nowrap;"><em>bmBc</em>&nbsp;table used by Horspool algorithm</span></font></p><p style="margin: 2px 6px 6px 12px; text-align: start;"><font color="#000000" face="Times New Roman" size="3">Searching&nbsp;phase</font></p><p style="margin: 2px 6px 6px 12px; text-align: start;"></p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 1 (<em>bmBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="13">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="9" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 1 (<em>bmBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="8" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 8 (<em>bmBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search" style="font-family: \'Times New Roman\';"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Seventh attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td></tr></tbody></table><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Shift by: 2 (<em>bmBc</em>[G])</p><p style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Horspool algorithm performs 17 character comparisons on the example.</p><p></p></div><p></p><p></p>', '2013-05-01 09:10:23', '2013-05-01 09:13:11', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(43, 'Quick Search', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Quick Search algorithm uses only the bad-character shift table (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm). After an attempt where the window is positioned on the text factor&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>&nbsp;..&nbsp;<i>j</i>+<i>m</i>-1]</span>, the length of the shift is at least equal to one. So, the character&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>+<i>m</i>]</span>&nbsp;is necessarily involved in the next attempt, and thus can be used for the bad-character shift of the current attempt.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The bad-character shift of the present algorithm is slightly modified to take into account the last character of&nbsp;<i>x</i>&nbsp;as follows: for&nbsp;<span style="white-space: nowrap;"><i>c</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"></span>,&nbsp;<span style="white-space: nowrap;"><em>qsBc</em>[<i>c</i>]=<em>min</em>{i&nbsp;<big>:</big>&nbsp;0&nbsp; &lt;&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>&nbsp;and&nbsp;<i>x</i>[<i>m</i>-<i>i</i>]=<i>c</i>}</span>&nbsp;if&nbsp;<i>c</i>&nbsp;occurs in&nbsp;<i>x</i>,&nbsp;<i>m</i>+1 otherwise (thanks to Darko Brljak).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;time and&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During the searching phase the comparisons between pattern and text characters during each attempt can be done in any order. The searching phase has a quadratic worst case time complexity but it has a good practical behaviour.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="line-height: normal;">simplification of the Boyer-Moore algorithm;</span><br></li><li><span style="line-height: normal;">uses only the bad-character shift;</span><br></li><li><span style="line-height: normal;">easy to implement;</span><br></li><li><span style="line-height: normal;">preprocessing phase in&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i>O</i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal;">time and</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i>O</i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity;</span><br></li><li><span style="line-height: normal;">very fast in practice for short patterns and large alphabets.</span><br></li></ul><div><br></div><div><b>Example:</b></div><div><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Quick Search algorithm qsBc table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/qstab1.png"><br clear="all"><span style="white-space: nowrap;"><em>qsBc</em>&nbsp;table used by Quick Search algorithm</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><span style="white-space: nowrap;">Searching phase:</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1 (<em>qsBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="22">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 9 (<em>qsBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>qsBc</em>[C])</p><p>The Quick Search algorithm performs 15 character comparisons on the example.</p></p></div></p></font></p>', '2013-05-01 09:16:43', '2013-05-01 09:18:33', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(44, 'Tuned Boyer-Moore', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Tuned Boyer-Moore is a implementation of a simplified version of the&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm which is very fast in practice. The most costly part of a string-matching algorithm is to check whether the character of the pattern match the character of the window. To avoid doing this part too often, it is possible to unrolled several shifts before actually comparing the characters. The algorithm used the bad-character shift function to find&nbsp;<i>x</i>[<i>m</i>-1] in&nbsp;<i>y</i>&nbsp;and keep on shifting until finding it, doing blindly three shifts in a row. This required to save the value of&nbsp;<em>bmBc</em>[<i>x</i>[<i>m</i>-1]] in a variable<em>shift</em>&nbsp;and then to set&nbsp;<em>bmBc</em>[<i>x</i>[<i>m</i>-1]] to 0. This required also to add&nbsp;<i>m</i>&nbsp;occurrences of&nbsp;<i>x</i>[<i>m</i>-1] at the end of&nbsp;<i>y</i>. When&nbsp;<i>x</i>[<i>m</i>-1] is found the&nbsp;<i>m</i>-1 other characters of the window are checked and a shift of length&nbsp;<em>shift</em>&nbsp;is applied.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The comparisons between pattern and text characters during each attempt can be done in any order. This algorithm has a quadratic worst-case time complexity but a very good practical behaviour.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="line-height: normal;"><p align="justify" style="margin: 2px 6px 6px 12px; display: inline !important;">simplification of the Boyer-Moore algorithm;</p></span><br></li><li><span style="line-height: normal;"><p align="justify" style="margin: 2px 6px 6px 12px; display: inline !important;">easy to implement;</p></span><br></li><li><span style="line-height: normal;"><p align="justify" style="margin: 2px 6px 6px 12px; display: inline !important;">very fast in practice.</p></span></li></ul><div><br></div><div style="text-align: left;"><b>Example:</b></div><div style="text-align: left;"><p style="margin: 2px 6px 6px 12px;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="bmBc table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/tndbmtab1.png"><br clear="all"><span style="white-space: nowrap;"><em>bmBc</em>&nbsp;table used by Tuned Boyer-Moore algorithm.</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><span style="white-space: nowrap;">Searching phase</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="white">3</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="white">4</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">5</td><td align="left" colspan="22">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>shift</em>)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="10" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="13">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>shift</em>)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="12">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>shift</em>)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="9" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="8" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="23" bgcolor="white">&nbsp;</td><td bgcolor="white">3</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="23" bgcolor="white">&nbsp;</td><td bgcolor="white">4</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">5</td><td align="left" colspan="7">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p>Shift by: 2 (<em>shift</em>)</p><p>The Tuned Boyer Moore algorithm performs 10 character comparisons on the example.</p></p></div><div><b><br></b></div></p></font></p>', '2013-05-01 09:19:40', '2013-05-01 09:22:05', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(45, 'Zhu-Takaoka', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Zhu and Takaoka designed an algorithm which performs the shift by considering the bad-character shift (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm) for two consecutive text characters.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During the searching phase the comparisons are performed from right to left and when the window is positioned on the text factor&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>&nbsp;..&nbsp;<i>j</i>+<i>m</i>-1]</span>&nbsp;and a mismatch occurs between&nbsp;<span style="white-space: nowrap;"><i>x</i>[<i>m</i>-<i>k</i>]</span>&nbsp;and&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>+<i>m</i>-<i>k</i>]</span>while&nbsp;<span style="white-space: nowrap;"><i>x</i>[<i>m</i>-<i>k</i>+1 ..&nbsp;<i>m</i>-1]=<i>y</i>[<i>j</i>+<i>m</i>-<i>k</i>+1 ..&nbsp;<i>j</i>+<i>m</i>-1]</span>&nbsp;the shift is performed with the bad-character shift for text characters&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>+<i>m</i>-2]</span>&nbsp;and&nbsp;<span style="white-space: nowrap;"><i>y</i>[<i>j</i>+<i>m</i>-1]</span>. The good-suffix shift table is also used to compute the shifts.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the algorithm consists in computing for each pair of characters&nbsp;<span style="white-space: nowrap;">(<i>a</i>,&nbsp;<i>b</i>)</span>&nbsp;with&nbsp;<span style="white-space: nowrap;"><i>a</i>,&nbsp;<i>b</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"></span>&nbsp;the rightmost occurrence of&nbsp;<i>ab</i>&nbsp;in&nbsp;<span style="white-space: nowrap;"><i>x</i>[0 ..&nbsp;<i>m</i>-2]</span>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>For&nbsp;<span style="white-space: nowrap;"><i>a</i>,<i>b</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"></span>:&nbsp;<em>ztBc</em>[<i>a</i>,&nbsp;<i>b</i>]=<i>k</i>&nbsp;iff</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>k</i>&lt;<i>m</i>-2 and&nbsp;<span style="white-space: nowrap;"><i>x</i>[<i>m</i>-<i>k</i>&nbsp;..&nbsp;<i>m</i>-<i>k</i>+1]=<i>ab</i></span>&nbsp;and&nbsp;<i>ab</i>&nbsp;does not occur in&nbsp;<span style="white-space: nowrap;"><i>x</i>[<i>m</i>-<i>k</i>+2 ..&nbsp;<i>m</i>-2]</span></td></tr></tbody></table></dd><dt>&nbsp; or &nbsp;</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>k</i>=<i>m</i>-1 and&nbsp;<span style="white-space: nowrap;"><i>x</i>[0]=<i>b</i></span>&nbsp;and&nbsp;<i>ab</i>&nbsp;does not occur in&nbsp;<span style="white-space: nowrap;"><i>x</i>[0 ..&nbsp;<i>m</i>-2]</span></td></tr></tbody></table></dd><dt>&nbsp; or &nbsp;</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>k</i>=<i>m</i>&nbsp;and&nbsp;<span style="white-space: nowrap;"><i>x</i>[0]&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;<i>b</i></span>&nbsp;and&nbsp;<i>ab</i>&nbsp;does not occur in&nbsp;<span style="white-space: nowrap;"><i>x</i>[0 ..&nbsp;<i>m</i>-2]</span></td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">It also consists in computing the table&nbsp;<em>bmGs</em>&nbsp;(see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"><sup>2</sup>)</span>&nbsp;time and space complexity. The searching phase has a quadratic worst case.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="line-height: normal;">variant of the Boyer-Moore algorithm;</span><br></li><li><span style="line-height: normal;">uses two consecutive text characters to compute the bad-character shift;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m+2) time and space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity.</span><br></li></ul></p></font></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b><br></b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Zhu-Takaoka algorithm tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/zttab1.png"><br clear="all"><span style="white-space: nowrap;"><em>ztBc</em>&nbsp;and&nbsp;<em>bmGs</em>&nbsp;tables used by Zhu-Takaoka algorithm.</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><span style="white-space: nowrap;">Searching phase</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 5 (<em>ztBc</em>[C][A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">6</td><td bgcolor="white">5</td><td bgcolor="white">4</td><td bgcolor="white">3</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>bmGs</em>[0])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="17" bgcolor="white">&nbsp;</td><td bgcolor="white">3</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>bmGs</em>[6])</p><p>The Zhu-Takaoka algorithm performs 12 character comparisons on the example.</p></p></p>', '2013-05-01 09:22:19', '2013-05-01 09:24:24', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(46, 'Berry-Ravindran', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Berry and Ravindran designed an algorithm which performs the shifts by considering the bad-character shift (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm) for the two consecutive text characters immediately to the right of the window.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the algorithm consists in computing for each pair of characters (<i>a</i>,&nbsp;<i>b</i>) with&nbsp;<i>a</i>,&nbsp;<i>b</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif">&nbsp;the rightmost occurrence of&nbsp;<i>ab</i>&nbsp;in&nbsp;<i>a</i><i>x</i><i>b</i>. For&nbsp;<i>a</i>,&nbsp;<i>b</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><br clear="all"><img align="MIDDLE" alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/br1.gif"></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase is in&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"><sup>2</sup>) space and time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">After an attempt where the window is positioned on the text factor&nbsp;<i>y</i>[<i>j</i>&nbsp;..&nbsp;<i>j</i>+<i>m</i>-1] a shift of length&nbsp;<span style="white-space: nowrap;"><em>brBc</em>[<i>y</i>[<i>j</i>+<i>m</i>],<i>y</i>[<i>j</i>+<i>m</i>+1]]</span>&nbsp;is performed. The text character&nbsp;<i>y</i>[<i>n</i>] is equal to the null character and&nbsp;<i>y</i>[<i>n</i>+1] is set to this null character in order to be able to compute the last shifts of the algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the Berry-Ravindran algorithm has a&nbsp;<big><i><b>O</b></i></big>(<i>m</i><i>n</i>) time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="line-height: normal;">hybrid of the Quick Search and Zhu and Takaoka algorithms;</span><br></li><li><span style="line-height: normal;">preprocessing phase in O(m+2) space and time complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity.</span><br></li></ul></p></font></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="brBc table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/brtab1.png"><br clear="all"><span style="white-space: nowrap;">The star (*) represents any character in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif">&nbsp;\\{A, C, G, T}.</span><br clear="all"><span style="white-space: nowrap;"><em>brBc</em>&nbsp;table used by Berry-Ravindran algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1 (<em>brBc</em>[G][A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="22">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>brBc</em>[A][G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>brBc</em>[A][G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 10 (<em>brBc</em>[T][A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="1" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>brBc</em>[G][0])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="7">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p>Shift by: 10 (<em>brBc</em>[0][0])</p><p>The Berry-Ravindran algorithm performs 16 character comparisons on the example.</p></p></p>', '2013-05-01 09:24:38', '2013-05-01 09:25:54', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(47, 'Smith', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Smith noticed that computing the shift with the text character just next the rightmost text character of the window gives sometimes shorter shift than using the rightmost text character of the window.<br>He advised then to take the maximum between the two values.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Smith algorithm consists in computing the bad-character shift function (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140" style="text-decoration: underline; color: black;">Boyer-Moore</a>&nbsp;algorithm) and the Quick Search bad-character shift function (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node19.html#SECTION00190" style="text-decoration: underline; color: black;">Quick Search</a>&nbsp;algorithm).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;time and&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the Smith algorithm has a quadratic worst case time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="line-height: normal;">takes the maximum of the Horspool bad-character shift function and the Quick Search bad-character shift function;</span><br></li><li><span style="line-height: normal;">preprocessing phase in&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal;">time and</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i><b>O</b></i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity.</span><br></li></ul></p></font></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Smith algorithm tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/smithtab1.png"><br clear="all"><span style="white-space: nowrap;"><em>bmBc</em>&nbsp;and&nbsp;<em>qsBc</em>&nbsp;tables used by Smith algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1 (<em>bmBc</em>[A]=<em>qsBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="22">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>bmBc</em>[G]=<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>bmBc</em>[G]=<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 9 (<em>qsBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>qsBc</em>[C])</p><p>The Smith algorithm performs 15 character comparisons on the example.</p></p></p>', '2013-05-01 09:25:59', '2013-05-01 09:27:42', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(48, 'Raita', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Raita designed an algorithm which at each attempt first compares the last character of the pattern with the rightmost text character of the window, then if they match it compares the first character of the pattern with the leftmost text character of the window, then if they match it compares the middle character of the pattern with the middle text character of the window. And finally if they match it actually compares the other characters from the second to the last but one, possibly comparing again the middle character.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Raita observed that its algorithm had a good behaviour in practice when searching patterns in English texts and attributed these performance to the existence of character dependencies.<br>Smith made some more experiments and concluded that this phenomenon may rather be due to compiler effects.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Raita algorithm consists in computing the bad-character shift function.&nbsp;It can be done in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;time and&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span>&nbsp;space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the Raita algorithm has a quadratic worst case time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><ul><li><span style="line-height: normal;">first compares the last pattern character, then the first and finally the middle one before actually comparing the others;</span><br></li><li><span style="line-height: normal;">performs the shifts like the Horspool algorithm;</span><br></li><li><span style="line-height: normal;">preprocessing phase in</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i>O</i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal;">time and</span><span style="line-height: normal;">&nbsp;</span><span style="line-height: normal; white-space: nowrap;"><big><i>O</i></big>(<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)</span><span style="line-height: normal;">&nbsp;space complexity;</span><br></li><li><span style="line-height: normal;">searching phase in O(mn) time complexity.</span></li></ul></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Horspool algorithm bmBc table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hotab1.png"><br clear="all"><span style="white-space: nowrap;"><em>bmBc</em>&nbsp;table used by Raita algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1 (<em>bmBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="15">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="13">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">3</td><td bgcolor="white">8</td><td bgcolor="white">9</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>bmBc</em>[G])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="7" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="9" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1 (<em>bmBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="8" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="8" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 8 (<em>bmBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Seventh attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>bmBc</em>[G])</p><p style="text-align: start;">The Raita algorithm performs 18 character comparisons on the example.</p></p>', '2013-05-01 09:27:45', '2013-05-01 09:37:07', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(49, 'Reverse Factor', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The&nbsp;Boyer-Moore&nbsp;type algorithms match some suffixes of the pattern but it is possible to match some prefixes of the pattern by scanning the character of the window from right to left and then improve the length of the shifts. This is made possible by the use of the smallest suffix automaton (also called DAWG for Directed Acyclic Word Graph) of the reverse pattern. The resulting algorithm is called the Reverse Factor algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The smallest suffix automaton of a word&nbsp;<i>w</i>&nbsp;is a Deterministic Finite Automaton&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>w</i>) =(<em><b>Q</b></em>,<em>q</em><sub>0</sub>,<em><b>T</b></em>,<em><b>E</b></em>)</span>. The language accepted by&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>w</i>)</span>&nbsp;is&nbsp;<span style="white-space: nowrap;"><em><big><b>L</b></big></em>(<em><big><b>S</b></big></em>(<i>w</i>))={<i>u</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup>&nbsp;<big>:</big>&nbsp; exists&nbsp;<i>v</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup>&nbsp;such that&nbsp;<i>w</i>=<i>v</i><i>u</i>}</span>. The preprocessing phase of the Reverse Factor algorithm consists in computing the smallest suffix automaton for the reverse pattern&nbsp;<i>x</i><sup><i>R</i></sup>. It is linear in time and space in the length of the pattern.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During the searching phase, the Reverse Factor algorithm parses the characters of the window from right to left with the automaton&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>x</i><sup><i>R</i></sup>)</span>, starting with state&nbsp;<span style="white-space: nowrap;">q<sub>0</sub></span>. It goes until there is no more transition defined for the current character of the window from the current state of the automaton. At this moment it is easy to know what is the length of the longest prefix of the pattern which has been matched: it corresponds to the length of the path taken in&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>x</i><sup><i>R</i></sup>)</span>&nbsp;from the start state&nbsp;<span style="white-space: nowrap;">q<sub>0</sub></span>&nbsp;to the last final state encountered. Knowing the length of this longest prefix, it is trivial to compute the right shift to perform.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Reverse Factor algorithm has a quadratic worst case time complexity but it is optimal in average. It performs&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(&nbsp;<i>n</i>.log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub>(<i>m</i>) /&nbsp;<i>m</i>&nbsp;)</span>&nbsp;inspections of text characters on the average reaching the best bound shown by Yao in 1979.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px;"><b style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Main features:</b><br><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">uses the suffix automaton of&nbsp;</font><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">x</i><sup style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i>R</i></sup><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">;</font><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">fast on practice for long pattens and small alphabets;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">preprocessing phase in O(m) time and space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(mn) time complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">optimal in the average.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Langage accepted" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/rfltab1.png"><br clear="all"><img alt="Suffix automaton" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/suffixauto1.png"><br clear="all"><span style="white-space: nowrap;">Suffix automaton used by Reverse Factor algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><div><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 5 (8 - 3)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">6</td><td bgcolor="white">5</td><td bgcolor="white">4</td><td bgcolor="white">3</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 7 (8 - 1)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 7 (8 - 1)</p><p style="text-align: start;">The Reverse Factor algorithm performs 17 character comparisons on the example.</p></div></p>', '2013-05-01 09:37:11', '2013-05-01 09:41:31', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(50, 'Turbo Reverse', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">It is possible to make the&nbsp;Reverse Factor&nbsp;algorithm linear. It is in fact enough to remember the prefix&nbsp;<i>u</i>&nbsp;of&nbsp;<i>x</i>&nbsp;matched during the last attempt. Then during the current attempt when reaching the right end of&nbsp;<i>u</i>, it is easy to show that it is sufficient to read again at most the rightmost half of&nbsp;<i>u</i>. This is made by the Turbo Reverse Factor algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">If a word&nbsp;<i>z</i>&nbsp;is a factor of a word&nbsp;<i>w</i>&nbsp;we define&nbsp;<i>disp</i>(<i>z</i>,<i>w</i>) the displacement of&nbsp;<i>z</i>&nbsp;in&nbsp;<i>w</i>&nbsp;to be the least integer&nbsp;<i>d</i>&gt;0 such that&nbsp;<i>w</i>[<i>m</i>-<i>d</i>-|<i>z</i>|-1 ..&nbsp;<i>m</i>-<i>d</i>]=<i>z</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The general situation of the Turbo Reverse Factor algorithm is when a prefix&nbsp;<i>u</i>&nbsp;is found in the text during the last attempt and for the current attempt the algorithm tries to match the factor&nbsp;<i>v</i>&nbsp;of length&nbsp;<i>m</i>-|<i>u</i>| in the text immediately at the right of&nbsp;<i>u</i>. If&nbsp;<i>v</i>&nbsp;is not a factor of&nbsp;<i>x</i>&nbsp;then the shift is computed as in the Reverse Factor algorithm. If&nbsp;<i>v</i>&nbsp;is a suffix of&nbsp;<i>x</i>&nbsp;then an occurrence of&nbsp;<i>x</i>&nbsp;has been found. If&nbsp;<i>v</i>&nbsp;is not a suffix but a factor of&nbsp;<i>x</i>&nbsp;then it is sufficient to scan again the&nbsp;<em>min</em>(<em>per</em>(<i>u</i>),|<i>u</i>|/2) rightmost characters of&nbsp;<i>u</i>. If&nbsp;<i>u</i>&nbsp;is periodic (i.e.&nbsp;<em>per</em>(<i>u</i>) &nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp; |<i>u</i>|/2) let&nbsp;<i>z</i>&nbsp;be the suffix of&nbsp;<i>u</i>&nbsp;of length&nbsp;<em>per</em>(<i>u</i>). By definition of the period&nbsp;<i>z</i>&nbsp;is an acyclic word and then an overlap such as shown in Figure&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node24.html#trf" style="text-decoration: underline; color: black;">23.1</a>&nbsp;is impossible.</p><p align="center" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><a id="trf" name="trf" style="text-decoration: underline;">&nbsp;</a>&nbsp;<img align="BOTTOM" alt="figure 23.1" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/trf1.gif"><br clear="all"><strong>Figure 23.1:</strong>&nbsp;Impossible overlap if&nbsp;<i>z</i>&nbsp;is an acyclic word.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Thus&nbsp;<i>z</i>&nbsp;can only occur in&nbsp;<i>u</i>&nbsp;at distances multiple of&nbsp;<em>per</em>(<i>u</i>) which implies that the smallest proper suffix of&nbsp;<i>uv</i>&nbsp;which is a prefix of&nbsp;<i>x</i>&nbsp;has a length equal to |<i>uv</i>|-<i>disp</i>(<i>zv</i>,<i>x</i>)=<i>m</i>-<i>disp</i>(<i>zv</i>,<i>x</i>). Thus the length of the shift to perform is&nbsp;<span style="white-space: nowrap;"><i>disp</i>(<i>zv</i>,<i>x</i>)</span>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">If&nbsp;<i>u</i>&nbsp;is not periodic (<em>per</em>(<i>u</i>)&gt;|<i>u</i>|/2), it is obvious that&nbsp;<i>x</i>&nbsp;can not reoccur in the left part of&nbsp;<i>u</i>&nbsp;of length&nbsp;<em>per</em>(<i>u</i>). It is then sufficient to scan the right part of&nbsp;<i>u</i>&nbsp;of length |<i>u</i>|-<em>per</em>(<i>u</i>) &lt; |<i>u</i>|/2 to find a non defined transition in the automaton.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The function&nbsp;<i>disp</i>&nbsp;is implemented directly in the automaton&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>x</i>)</span>&nbsp;without changing the complexity of its construction.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase consists in building the suffix automaton of&nbsp;<i>x</i><sup><i>R</i></sup>. It can be done in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>m</i>)</span>&nbsp;time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase is in&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(<i>n</i>)</span>&nbsp;time complexity. The Turbo Reverse Factor performs at most 2<i>n</i>&nbsp;inspections of text characters and it is also optimal in average performing&nbsp;<span style="white-space: nowrap;"><big><i><b>O</b></i></big>(&nbsp;<i>n</i>.log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub>(<i>m</i>) /&nbsp;<i>m</i>&nbsp;)</span>inspections of text characters on the average reaching the best bound shown by Yao in 1979.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">refinement of the Reverse Factor algorithm;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">preprocessing phase in O(m) time and space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(n) time complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">performs 2n text characters inspections in the worst case;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">optimal in the average.</span></li></ul><div><span style="line-height: 20px;"><br></span></div></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Langage accepted" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/rfltab1.png"><br clear="all"><img alt="Suffix automaton" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/suffixauto1.png"><br clear="all"><span style="white-space: nowrap;">Suffix automaton used by Turbo Reverse Factor algorithm.</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><span style="white-space: nowrap;">Searching phase</span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 5 (8 - 3)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">5</td><td bgcolor="white">4</td><td bgcolor="white">3</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (8 - 1)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (8 - 1)</p><p>The Turbo Reverse Factor algorithm performs 13 character comparisons on the example.</p></p></p>', '2013-05-01 09:41:57', '2013-05-01 09:45:13', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(51, 'Forward Dawg Matching', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Forward Dawg Matching algorithm computes the longest factor of the pattern ending at each position in the text. This is make possible by the use of the smallest suffix automaton (also called DAWG for Directed Acyclic Word Graph) of the pattern. The smallest suffix automaton of a word&nbsp;<i>w</i>&nbsp;is a Deterministic Finite Automaton&nbsp;<span style="white-space: nowrap;"><em><big><b>S</b></big></em>(<i>w</i>) = (<em><b>Q</b></em>,&nbsp;<i>q</i><sub>0</sub>,&nbsp;<em><b>T</b></em>,&nbsp;<em><b>E</b></em>)</span>. The language accepted by&nbsp;<em><big><b>S</b></big></em>(<i>w</i>) is<span style="white-space: nowrap;"><em><big><b>L</b></big></em>(<em><big><b>S</b></big></em>(<i>w</i>))={<i>u</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup>&nbsp;<big>:</big>&nbsp; exists&nbsp;<i>v</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup></span>&nbsp;such that&nbsp;<i>w</i>=<i>vu</i>}.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Forward Dawg Matching algorithm consists in computing the smallest suffix automaton for the pattern&nbsp;<i>x</i>. It is linear in time and space in the length of the pattern.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During the searching phase the Forward Dawg Matching algorithm parses the characters of the text from left to right with the automaton&nbsp;<em><big><b>S</b></big></em>(<i>x</i>) starting with state&nbsp;<i>q</i><sub>0</sub>. For each state&nbsp;<i>q</i>&nbsp;in&nbsp;<em><big><b>S</b></big></em>(<i>x</i>) the longest path from&nbsp;<i>q</i><sub>0</sub>&nbsp;to&nbsp;<i>p</i>&nbsp;is denoted by&nbsp;<em>length</em>(<i>q</i>). This structure extensively uses the notion of suffix links. For each state&nbsp;<i>p</i>&nbsp;the suffix link of&nbsp;<i>p</i>&nbsp;is denoted by&nbsp;<i>S</i>[<i>p</i>]. For a state&nbsp;<i>p</i>, let&nbsp;<em>Path</em>(<i>p</i>)=(<i>p</i><sub>0</sub>,<i>p</i><sub>1</sub>, ... ,<i>p</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>) be the suffix path of&nbsp;<i>p</i>&nbsp;such that&nbsp;<i>p</i><sub>0</sub>=<i>p</i>, for 1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">,&nbsp;<i>p</i><sub><i>i</i></sub>=<i>S</i>[<i>p</i><sub><i>i</i>-1</sub>] and&nbsp;<i>p</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>=<i>q</i><sub>0</sub>. For each text character&nbsp;<i>y</i>[<i>j</i>] sequentially, let&nbsp;<i>p</i>&nbsp;be the current state, then the Forward Dawg Matching algorithm takes a transition defined for&nbsp;<i>y</i>[<i>j</i>] for the first state of&nbsp;<em>Path</em>(<i>p</i>) for which such a transition is defined. The current state&nbsp;<i>p</i>&nbsp;is updated with the target state of this transition or with the initial state&nbsp;<i>q</i><sub>0</sub>&nbsp;if no transition exists labelled with&nbsp;<i>y</i>[<i>j</i>] from a state of&nbsp;<em>Path</em>(<i>p</i>).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">An occurrence of&nbsp;<i>x</i>&nbsp;is found when&nbsp;<em>length</em>(<i>p</i>)=<i>m</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Forward Dawg Matching algorithm performs exactly&nbsp;<i>n</i>&nbsp;text character inspections.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">uses the suffix automaton of x;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">O(n) worst case time complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">performs exactly n text character inspections.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Forward Dawg Automaton" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/fdmauto1.png"><br clear="all"><span style="white-space: nowrap;">Suffix automaton used by Forward Dawg Matching Search algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">0</td><td align="left" colspan="20">&nbsp;</td></tr></tbody></table><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">C</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">0</td><td align="left" colspan="18">&nbsp;</td></tr></tbody></table><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">7</td><td bgcolor="white">9</td><td bgcolor="white">1</td><td bgcolor="white">0</td><td align="left" colspan="10">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr></tbody></table><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">6</td><td bgcolor="white">0</td><td align="left" colspan="8">&nbsp;</td></tr></tbody></table><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">6</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">0</td><td align="left" colspan="3">&nbsp;</td></tr></tbody></table><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">C</td><td bgcolor="gray">G</td></tr><tr><td colspan="21" bgcolor="white">&nbsp;</td><td bgcolor="white">6</td><td bgcolor="white">2</td><td bgcolor="white">1</td></tr></tbody></table><p>The Forward Dawg Matching algorithm performs 24 character comparisons on the example.</p></p></p>', '2013-05-01 09:46:10', '2013-05-01 09:50:25', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(53, 'Backward Nondeterministic Dawg Matching', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The BNDM algorithm uses a table&nbsp;<em><b>B</b></em>&nbsp;which, for each character&nbsp;<i>c</i>, stores a bit mask. The mask in&nbsp;<em><b>B</b></em><sub><i>c</i></sub>&nbsp;is set if and only if&nbsp;<i>x</i><sub>i</sub>=<i>c</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The search state is kept in a word&nbsp;<em><b>d</b></em>=<i>d</i><sub><i>m</i>-1</sub>&nbsp;..&nbsp;<i>d</i><sub>0</sub>, where the pattern length&nbsp;<i>m</i>&nbsp;is less than or equal to the machine word size.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The bit&nbsp;<i>d<sub>i</sub></i>&nbsp;at iteration&nbsp;<tt><big><tt>k</tt></big></tt>&nbsp;is set if an only if&nbsp;<i>x</i>[<i>m</i>-<i>i</i>&nbsp;..&nbsp;<i>m</i>-1-<i>i</i>+<i>k</i>]=<i>y</i>[<i>j</i>+<i>m</i>-<i>k</i>&nbsp;..&nbsp;<i>j</i>+<i>m</i>-1]. At iteration 0,&nbsp;<em><b>d</b></em>&nbsp;is set to 1<sup><i>m</i>-1</sup>. The formula to update&nbsp;<em><b>d</b></em>&nbsp;follows&nbsp;<i>d</i>\'= (<i>d</i>&nbsp;&amp;&nbsp;<em><b>B</b></em>[<i>y</i><sub><i>j</i></sub>]) &lt;&lt; 1.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">There is a match if and only if, after iteration m, it holds&nbsp;<i>d</i><sub><i>m</i>-1</sub>=1.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Whenever&nbsp;<i>d</i><sub><i>m</i>-1</sub>=1, the algorithm has matched a prefix of the pattern in the current window position&nbsp;<i>j</i>. The longuest prefix matched gives the shift to the next position.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">variant of the Reverse Factor algorithm;</span><br></li><li><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">uses bit-parallelism simulation of the suffix automaton of&nbsp;</font><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; text-align: left;">x</i><sup style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; text-align: left;"><i>R</i></sup><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">;</font><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">efficient if the pattern length is no longer than the memory-word size of the machine;</span><br></li></ul></p></p>', '2013-05-01 09:53:23', '2013-05-01 09:54:28', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(54, 'Backward Oracle Matching', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The&nbsp;Boyer-Moore&nbsp;type algorithms match some suffixes of the pattern but it is possible to match some prefixes of the pattern by scanning the character of the window from right to left and then improve the length of the shifts. This is make possible by the use of the suffix oracle of the reverse pattern. This data structure is a very compact automaton which recognizes at least all the suffixes of a word and slightly more other words The string-matching algorithm using the&nbsp;<em><b>oracle</b></em>&nbsp;of the reverse pattern is called the Backward Oracle Matching algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The suffix oracle of a word&nbsp;<i>w</i>&nbsp;is a Deterministic Finite Automaton&nbsp;<em><big><b>O</b></big></em>(<i>w</i>) =(<em><b>Q</b></em>,&nbsp;<i>q</i><sub>0</sub>,&nbsp;<em><b>T</b></em>,&nbsp;<em><b>E</b></em>).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The language accepted by&nbsp;<em><big><b>O</b></big></em>(<i>w</i>) is such that {<i>u</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup>&nbsp;<big>:</big>&nbsp; exists&nbsp;<i>v</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif"><sup>*</sup>&nbsp;such that&nbsp;<i>w</i>&nbsp;=&nbsp;<i>vu</i>} in&nbsp;<em><big><b>L</b></big></em>(<em><big><b>O</b></big></em>(<i>w</i>)).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Backward Oracle Matching algorithm consists in computing the suffix oracle for the reverse pattern&nbsp;<i>x</i><sup><i>R</i></sup>. Despite the fact that it is able to recognize words that are not factor of the pattern, the suffix oracle can be used to do string-matching since the only word of length greater or equal&nbsp;<i>m</i>&nbsp;which is recognized by the oracle is the reverse pattern itself. The computation of the oracle is linear in time and space in the length of the pattern.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During the searching phase the Backward Oracle Matching algorithm parses the characters of the window from right to left with the automaton&nbsp;<em><big><b>O</b></big></em>(<i>x</i><sup><i>R</i></sup>) starting with state&nbsp;<i>q</i><sub>0</sub>. It goes until there is no more transition defined for the current character. At this moment the length of the longest prefix of the pattern which is a suffix of the scanned part of the text is less than the length of the path taken in<em><big><b>O</b></big></em>(<i>x</i><sup><i>R</i></sup>) from the start state&nbsp;<i>q</i><sub>0</sub>&nbsp;and the last final state encountered. Knowing this length, it is trivial to compute the length of the shift to perform.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Backward Oracle Matching algorithm has a quadratic worst case time complexity but it is optimal in average. On the average it performs&nbsp;<big><i><b>O</b></i></big>(<i>n</i>.(log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub><i>m</i>) /&nbsp;<i>m</i>) inspections of text characters reaching the best bound shown by Yao in 1979.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">version of the Reverse Factor algorithm using the suffix oracle of&nbsp;</font><i style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">x</i><sup style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i>R</i></sup><font color="#000000" face="Times New Roman" size="3">&nbsp;instead of the suffix automaton of&nbsp;</font><i style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">x</i><sup style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i>R</i></sup><font color="#000000" face="Times New Roman" size="3">;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">fast in practice for very long patterns and small alphabets;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">preprocessing phase in O(m) time and space complexity;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">searching phase in O(mn) time complexity;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">optimal in the average.</font></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Oracle" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bomauto1.png"><br clear="all"><img alt="B.O.M. tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bomtab1.png"><br clear="all"><span style="white-space: nowrap;">Oracle used by Backward Oracle Matching algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 5 (8 - 3)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">6</td><td bgcolor="white">5</td><td bgcolor="white">4</td><td bgcolor="white">3</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (8 - 1)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">*</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (8 - 1)</p><p>The Backward Oracle Matching algorithm algorithm performs 17 character comparisons on the example.</p></p></p>', '2013-05-01 09:54:50', '2013-05-01 09:56:53', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(55, 'Galil-Seiferas', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Throughout this section we will use a constant&nbsp;<i>k</i>. Galil and Seiferas suggest that practically this constant could be equal to 4.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Let us define the function&nbsp;<em>reach</em>&nbsp;for&nbsp;<span style="white-space: nowrap;">0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;&lt;&nbsp;<i>m</i></span>&nbsp;as follows:&nbsp;<span style="white-space: nowrap;"><em>reach</em>(<i>i</i>)=<i>i</i>+<em>max</em>{<i>i</i>’&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>-<i>i</i>&nbsp;<big>:</big>&nbsp;<i>x</i>[0 ..&nbsp;<i>i</i>’]=<i>x</i>[<i>i</i>+1 ..&nbsp;<i>i</i>’+<i>i</i>+1]}</span></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Then a prefix&nbsp;<i>x</i>[0 ..&nbsp;<i>p</i>] of&nbsp;<i>x</i>&nbsp;is a&nbsp;<em><b>prefix period</b></em>&nbsp;if it is basic and&nbsp;<em>reach</em>(<i>p</i>) &nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;<i>kp</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Galil-Seiferas algorithm consists in finding a decomposition&nbsp;<i>uv</i>&nbsp;of&nbsp;<i>x</i>&nbsp;such that&nbsp;<i>v</i>&nbsp;has at most one prefix period and |<i>u</i>|=<big><i><b>O</b></i></big>(<em>per</em>(<i>v</i>)). Such a decomposition is called a<em><b>perfect factorization</b></em>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Then the searching phase consists in scanning the text&nbsp;<i>y</i>&nbsp;for every occurrences of&nbsp;<i>v</i>&nbsp;and when&nbsp;<i>v</i>&nbsp;occurs to check naively if&nbsp;<i>u</i>&nbsp;occurs just before in&nbsp;<i>y</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">In the implementation below the aim of the preprocessing phase (functions&nbsp;<tt><big><tt>newP1</tt></big></tt>,&nbsp;<tt><big><tt>newP2</tt></big></tt>&nbsp;and&nbsp;<tt><big><tt>parse</tt></big></tt>) is to find a perfect factorization&nbsp;<i>uv</i>&nbsp;of&nbsp;<i>x</i>&nbsp;where&nbsp;<i>u</i>=<i>x</i>[0 ..&nbsp;<i>s</i>-1] and&nbsp;<i>v</i>=<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1]. Function<tt><big><tt>newP1</tt></big></tt>&nbsp;finds the shortest prefix period of<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1]. Function&nbsp;<tt><big><tt>newP2</tt></big></tt>&nbsp;finds the second shortest prefix period of&nbsp;<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] and function&nbsp;<tt><big><tt>parse</tt></big></tt>&nbsp;increments&nbsp;<i>s</i>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>Before calling function&nbsp;<em>search</em>&nbsp;we have:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] has at most one prefix period;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">if&nbsp;<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] does have a prefix period, then its length is&nbsp;<i>p</i><sub>1</sub>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>s</i>+<i>p</i><sub>1</sub>+<i>q</i><sub>1</sub>-1] has shortest period of length&nbsp;<i>p</i><sub>1</sub>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>s</i>+<i>p</i><sub>1</sub>+<i>q</i><sub>1</sub>] does not have period of length&nbsp;<i>p</i><sub>1</sub>.</td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The pattern&nbsp;<i>x</i>&nbsp;is of the form&nbsp;<i>x</i>[0 ..&nbsp;<i>s</i>-1]<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] where&nbsp;<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] is of the form&nbsp;<i>z</i><sup><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sup><i>z</i>’<i>a</i><i>z</i>” with&nbsp;<i>z</i>&nbsp;basic, |<i>z</i>|=<i>p</i><sub>1</sub>,&nbsp;<i>z</i>’ prefix of&nbsp;<i>z</i>,&nbsp;<i>z</i>’<i>a</i>&nbsp;not a prefix of&nbsp;<i>z</i>&nbsp;and |<i>z</i><sup><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sup><i>z</i>’| =<i>p</i><sub>1</sub>+<i>q</i><sub>1</sub>&nbsp;(see figure&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node25.html#figgs" style="text-decoration: underline; color: black;">24.1</a>).</p><p align="center" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><a id="figgs" name="figgs" style="text-decoration: underline;">&nbsp;</a>&nbsp;<img align="BOTTOM" alt="figure 24.1" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gs1.gif"><br clear="all"><strong>Figure 24.1:</strong>&nbsp;A perfect factorization of&nbsp;<i>x</i>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>It means that when searching for&nbsp;<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>m</i>-1] in&nbsp;<i>y</i>:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">if&nbsp;<i>x</i>[<i>s</i>&nbsp;..&nbsp;<i>s</i>+<i>p</i><sub>1</sub>+<i>q</i><sub>1</sub>-1] has been matched a shift of length&nbsp;<i>p</i><sub>1</sub>&nbsp;can be performed and the comparisons are resumed with&nbsp;<i>x</i>[<i>s</i>+<i>q</i><sub>1</sub>];</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">otherwise if a mismatch occurs with&nbsp;<i>x</i>[<i>s</i>+<i>q</i>] with&nbsp;<i>q</i>&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;<i>p</i><sub>1</sub>+<i>q</i><sub>1</sub>&nbsp;then a shift of length&nbsp;<i>q</i>/<i>k</i>+1 can be performed and the comparisons are resumed with&nbsp;<i>x</i>[0].</td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">This gives an overall linear number of text character comparisons.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Galil-Seiferas algorithm is in&nbsp;<big><i><b>O</b></i></big>(<i>m</i>) time and constant space complexity. The searching phase is in&nbsp;<big><i><b>O</b></i></big>(<i>n</i>) time complexity. At most 5<i>n</i>&nbsp;text character comparisons can be done during this phase.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">constant extra space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">preprocessing phase in O(m) time and constant space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(n) time complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">performs 5n text character comparisons in the worst case.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><i>p</i>=0,&nbsp;&nbsp;<i>q</i>=0,&nbsp;&nbsp;<i>s</i>=0,&nbsp;&nbsp;<i>p</i><sub>1</sub>=7,&nbsp;&nbsp;<i>q</i><sub>1</sub>=1.</p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><div><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="22">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="2" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="21">&nbsp;</td></tr><tr><td colspan="2" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="14" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="19">&nbsp;</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="12" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 7 (p1)</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Seventh attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="13" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="10">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Eighth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="13" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="10">&nbsp;</td></tr><tr><td colspan="13" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="3" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Ninth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Tenth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="1" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Eleventh attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="7">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p style="text-align: start;">Shift by: 1</p><p style="text-align: start;">The Galil-Seiferas algorithm performs 25 character comparisons on the example.</p></div></p>', '2013-05-01 09:56:55', '2013-05-01 09:58:13', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(56, 'Two Way', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The pattern&nbsp;<i>x</i>&nbsp;is factorized in two parts&nbsp;<i>x</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>&nbsp;and&nbsp;<i>x</i><sub><i>r</i></sub>&nbsp;such that&nbsp;<i>x</i>=<i>x</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>x<sub><i>r</i></sub>. Then the search phase of the Two Way algorithm consists in comparing the characters of&nbsp;<i>x</i><sub><i>r</i></sub>&nbsp;from left to right and then, if no mismatch occurs during that first stage, in comparing the characters of&nbsp;<i>x</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>&nbsp;from right to left in a second stage.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the algorithm consists then in choosing a good&nbsp;<em><b>factorization</b></em>&nbsp;&nbsp;<i>x</i><sub><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>x<sub><i>r</i></sub>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p align="justify" style="margin: 2px 6px 6px 12px;"><b>Definition</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"></p><p align="justify" style="margin: 2px 6px 0px 12px;">Let (<i>u</i>,&nbsp;<i>v</i>) be a factorization of&nbsp;<i>x</i>. A&nbsp;<em><b>repetition</b></em>&nbsp;in (<i>u</i>,&nbsp;<i>v</i>) is a word&nbsp;<i>w</i>&nbsp;such that the two following properties hold:</p><ul type="i" style="margin-right: 18px; margin-bottom: 0px; text-align: start;"><li style="padding-top: 3px;"><i>w</i>&nbsp;is a suffix of&nbsp;<i>u</i>&nbsp;or&nbsp;<i>u</i>&nbsp;is a suffix of&nbsp;<i>w</i>;</li><li style="padding-top: 3px;"><i>w</i>&nbsp;is a prefix of&nbsp;<i>v</i>&nbsp;of&nbsp;<i>v</i>&nbsp;is a prefix of&nbsp;<i>w</i>.</li></ul><p align="justify" style="margin: 2px 6px 6px 12px;">In other words&nbsp;<i>w</i>&nbsp;occurs at both sides of the cut between&nbsp;<i>u</i>&nbsp;and&nbsp;<i>v</i>&nbsp;with a possible overflow on either side. The length of a repetition in (<i>u</i>,<i>v</i>) is called a&nbsp;<em><b>local period</b></em>&nbsp;and the length of the smallest repetition in (<i>u</i>,<i>v</i>) is called the&nbsp;<em><b>local period</b></em>&nbsp;and is denoted by&nbsp;<i>r</i>(<i>u</i>,<i>v</i>).</p><p align="justify" style="margin: 2px 6px 6px 12px;">Each factorization (<i>u</i>,<i>v</i>) of has at least one repetition. It can be easily seen that&nbsp;<span style="white-space: nowrap;">1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>r</i>(<i>u</i>,<i>v</i>)&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp; |<i>x</i>|</span></p><p align="justify" style="margin: 2px 6px 6px 12px;">A factorization (<i>u</i>,<i>v</i>) of&nbsp;<i>x</i>&nbsp;such that&nbsp;<i>r</i>(<i>u</i>,<i>v</i>)=<em>per</em>(<i>x</i>) is called a&nbsp;<em><b>critical factorization</b></em>&nbsp;of&nbsp;<i>x</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px;"></p><p align="justify" style="margin: 2px 6px 6px 12px;">If (<i>u</i>,<i>v</i>) is a critical factorization of&nbsp;<i>x</i>&nbsp;then at the position |<i>u</i>| in&nbsp;<i>x</i>&nbsp;the global and the local periods are the same. The Two Way algorithm chooses the critical factorization (<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>,<i>x</i><sub style="font-size: 12px;"><i>r</i></sub>) such that |<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>| &lt;&nbsp;<em>per</em>(<i>x</i>) and |<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>| is minimal.</p><p align="justify" style="margin: 2px 6px 6px 12px;">To compute the critical factorization&nbsp;<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>,<i>x</i><sub style="font-size: 12px;"><i>r</i></sub>&nbsp;of&nbsp;<i>x</i>&nbsp;we first compute the maximal suffix&nbsp;<i>z</i>&nbsp;of&nbsp;<i>x</i>&nbsp;for the order &nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp; and the maximal suffix&nbsp;<img alt="z tilde" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ztilde.gif">&nbsp;for the reverse order&nbsp;<img alt="leq tilde" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leqtilde.gif">. Then (<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>,<i>x</i><sub style="font-size: 12px;"><i>r</i></sub>) is chosen such that. |<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>|=<em>max</em>{|<i>z</i>|,|<img alt="z tilde" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ztilde.gif">|}</p><p align="justify" style="margin: 2px 6px 6px 12px;">The preprocessing phase can be done in&nbsp;<big><i><b>O</b></i></big>(<i>m</i>) time and constant space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px;">The searching phase of the Two Way algorithm consists in first comparing the character of&nbsp;<i>x</i><sub style="font-size: 12px;"><i>r</i></sub>&nbsp;from left to right, then the character of&nbsp;<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>&nbsp;from right to left.</p><p align="justify" style="margin: 2px 6px 6px 12px;">When a mismatch occurs when scanning the&nbsp;<i>k</i>-th character of&nbsp;<i>x</i><sub style="font-size: 12px;"><i>r</i></sub>, then a shift of length&nbsp;<i>k</i>&nbsp;is performed.</p><p align="justify" style="margin: 2px 6px 6px 12px;">When a mismatch occurs when scanning&nbsp;<i>x</i><sub style="font-size: 12px;"><img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif"></sub>, or when an occurrence of the pattern is found, then a shift of length&nbsp;<em>per</em>(<i>x</i>) is performed.</p><p align="justify" style="margin: 2px 6px 6px 12px;">Such a scheme leads to a quadratic worst case algorithm, this can be avoided by a prefix memorization: when a shift of length&nbsp;<em>per</em>(<i>x</i>) is performed the length of the matching prefix of the pattern at the beginning of the window (namely&nbsp;<i>m</i>-<em>per</em>(<i>x</i>)) after the shift is memorized to avoid to scan it again during the next attempt.</p><p align="justify" style="margin: 2px 6px 6px 12px;">The searching phase of the Two Way algorithm can be done in&nbsp;<big><i><b>O</b></i></big>(<i>n</i>) time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px;">The Two Way algorithm performs 2<i>n</i>-<i>m</i>&nbsp;text character comparisons in the worst case. Breslauer designed a variation on the Two Way algorithm which performs less than 2<i>n</i>-<i>m</i>&nbsp;comparisons using constant space.</p><div><br></div></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">requires an ordered alphabet;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">preprocessing phase in O(m) time and constant space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">constant space complexity for the preprocessing phase;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(n) time;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">performs 2n-m text character comparisons in the worst case.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Factorization" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/twtab1.png"><br clear="all"><span style="white-space: nowrap;">Factorisation used by Two Way algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="2" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="19">&nbsp;</td></tr><tr><td colspan="2" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="14" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="18">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="6" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="17">&nbsp;</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="12" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="12" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="4" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Seventh attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td align="left" colspan="6">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Eighth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="18" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td align="left" colspan="3">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p>Shift by: 3</p><p>The Two Way algorithm performs 20 character comparisons on the example.</p></p></p>', '2013-05-01 09:58:25', '2013-05-01 10:00:46', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(57, 'String Matching on Ordered Alphabets', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">During an attempt where the window is positioned on the text factor&nbsp;<i>y</i>[<i>j</i>&nbsp;..&nbsp;<i>j</i>+<i>m</i>-1], when a prefix&nbsp;<i>u</i>&nbsp;of&nbsp;<i>x</i>&nbsp;has been matched and a mismatch occurs between characters&nbsp;<i>a</i>&nbsp;in&nbsp;<i>x</i>&nbsp;and&nbsp;<i>b</i>&nbsp;in&nbsp;<i>y</i>&nbsp;(<i>see figure 26.1</i>), the algorithm tries to compute the period of&nbsp;<i>ub</i>, if it does not succeed in finding the exact period it computes an approximation of it.</p><p align="center" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><img align="BOTTOM" alt="figure 26.1" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/smoa1.png"><br clear="ALL"><strong>Figure 26.1:</strong>&nbsp;Typical attempt during the String Matching on an Ordered Alphabet algorithm.</p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Definition</b></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dl style="margin: 2px 6px 6px 12px;"><dt>Let us define&nbsp;<i>tw</i><sup><i>e</i></sup><i>w</i>\' the&nbsp;<em>Maximal-Suffix decomposition</em>&nbsp;(MS-decompostion for short) of the word&nbsp;<i>x</i>&nbsp;if:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>v</i>&nbsp;=&nbsp;<i>w</i><sup><i>e</i></sup><i>w</i>\' is the maximal suffix of&nbsp;<i>x</i>&nbsp;according to the alphabetical ordering;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>w</i>&nbsp;is basic;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>e</i>&nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;1;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>w</i>\' is a proper prefix of&nbsp;<i>w</i>.</td></tr></tbody></table></dd></dl><p style="margin: 2px 6px 6px 12px;">Then we have |<i>t</i>| &lt; per/&gt;(<i>x</i>).</p><p style="margin: 2px 6px 6px 12px;">If&nbsp;<i>tw</i><sup><i>e</i></sup><i>w</i>\' is the MS-decomposition of a nonempty word&nbsp;<i>x</i>&nbsp;then the four properties hold:</p><dl style="margin: 2px 6px 6px 12px;"><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">if&nbsp;<i>t</i>&nbsp;is a suffix of&nbsp;<i>w</i>&nbsp;then&nbsp;<em>per</em>(<i>x</i>) =&nbsp;<em>per</em>(<i>v</i>);</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>per</em>(<i>x</i>) &gt; |<i>t</i>|;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">if |<i>t</i>|&nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;|<i>w</i>| then&nbsp;<em>per</em>(<i>x</i>) &gt; |<i>v</i>| = |<i>x</i>|-|<i>t</i>|;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP">if&nbsp;<i>t</i>&nbsp;is not a suffix of&nbsp;<i>w</i>&nbsp;and |<i>t</i>| &lt; |<i>w</i>| then&nbsp;<em>per</em>(<i>x</i>) &gt;&nbsp;<em>min</em>(|<i>v</i>,|<i>tw</i><sup><i>e</i></sup>|).</td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px;">If&nbsp;<i>u</i>&nbsp;is a suffix of&nbsp;<i>w</i>&nbsp;then&nbsp;<em>per</em>(<i>x</i>)=<em>per</em>(<i>v</i>)=|<i>w</i>|.<br>Otherwise&nbsp;<em>per</em>(<i>x</i>) &gt;&nbsp;<em>max</em>(|<i>u</i>,<em>min</em>(|<i>v</i>|, |<i>tw</i><sup><i>e</i></sup>|)) &nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp; |<i>x</i>|/2.</p><p align="justify" style="margin: 2px 6px 6px 12px;">If&nbsp;<i>tw</i><sup><i>e</i></sup><i>w</i>\' is the MS-decomposition of a nonempty word&nbsp;<i>x</i>,&nbsp;<em>per</em>(<i>x</i>) = |<i>w</i>| and&nbsp;<i>e</i>&nbsp;&gt; 1 then If&nbsp;<i>tw</i><sup><i>e</i>-1</sup><i>w</i>\' is the MS-decomposition of&nbsp;<i>x</i>\' =&nbsp;<i>uw</i><sup><i>e</i>-1</sup><i>w</i>\'.</p></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p align="justify" style="margin: 2px 6px 6px 12px;"><span style="text-align: left;"><br></span></p><p align="justify" style="margin: 2px 6px 6px 12px;"><span style="text-align: left;">The algorithm computes the maximal suffix of the matched prefix of the pattern appended with the mismatched character of the text after each attempt. It avoids to compute it from scratch after a shift of length&nbsp;</span><em style="text-align: left;">per</em><span style="text-align: left;">(</span><i style="text-align: left;">w</i><span style="text-align: left;">)$ has been performed.</span><br></p><p align="justify" style="margin: 2px 6px 6px 12px;">The String Matching on Ordered Alphabets needs no preprocessing phase.</p><p align="justify" style="margin: 2px 6px 6px 12px;">The searching phase can be done in&nbsp;<big><i><b>O</b></i></big>(<i>n</i>) time complexity using a constant extra space. The algorithm performs no more than 6<i>n</i>+5 text character comparisons.</p><p align="justify" style="margin: 2px 6px 6px 12px;"><img width="527" height="115" align="BOTTOM" alt="figure 26.2" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/smoa2.png" style="text-align: -webkit-center;"></p></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><strong style="text-align: -webkit-center;">Figure 26.2:</strong><span style="text-align: -webkit-center;">&nbsp;Meaning of the variables&nbsp;</span><i style="text-align: -webkit-center;">i</i><span style="text-align: -webkit-center;">,&nbsp;</span><i style="text-align: -webkit-center;">j</i><span style="text-align: -webkit-center;">,&nbsp;</span><i style="text-align: -webkit-center;">k</i><span style="text-align: -webkit-center;">,&nbsp;</span><i style="text-align: -webkit-center;">p</i><span style="text-align: -webkit-center;">&nbsp;in the function&nbsp;</span><tt style="text-align: -webkit-center;"><big><tt>NEXT_MAXIMAL_SUFFIX</tt></big></tt><span style="text-align: -webkit-center;">.</span><br></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="text-align: -webkit-center;"><br></span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="text-align: -webkit-center;"><b>Example:</b></span></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 4</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="19">&nbsp;</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="12" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 9</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="9">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="1" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 1</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Sixth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="7">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p>Shift by: 1</p><p>The String Matching on Ordered Alphabet algorithm performs 27 character comparisons on the example.</p></p><p align="center" style="text-align: left; margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="text-align: -webkit-center;"><br></span></p>', '2013-05-01 10:00:50', '2013-05-01 10:04:09', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(58, 'Optimal mismatch', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Sunday designed an algorithm where the pattern characters are scanned from the least frequent one to the most frequent one. Doing so one may hope to have a mismatch most of the times and thus to scan the whole text very quickly. One needs to know the frequencies of each of the character of the alphabet.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Optimal Mismatch algorithm consists in sorting the pattern characters in decreasing order of their frequencies and then in building the Quick Search bad-character shift function (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node19.html#SECTION00190" style="text-decoration: underline; color: black;">Quick Search</a>&nbsp;algorithm) and a good-suffix shift function adapted to the scanning order of the pattern characters. It can be done in&nbsp;<big><i><b>O</b></i></big>(<i>m</i><sup>2</sup>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">) time and&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">) space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the Optimal Mismatch algorithm has a&nbsp;<big><i><b>O</b></i></big>(<i>m</i><i>n</i>) time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">variant of the Quick Search algorithm;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">requires the frequencies of the characters;</span><br></li><li><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">preprocessing phase in&nbsp;</font><big style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i><b>O</b></i></big><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">(</span><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">m</i><sup style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';">2</sup><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">) time and</span><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">&nbsp;</span><big style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i><b>O</b></i></big><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">(</span><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">m</i><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">) space complexity.</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(mn) time complexity.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Optimal Mismatch algorithm tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/omtab1.png"><br clear="all"><span style="white-space: nowrap;">Tables used by Optimal Mismatch algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 3 (<i>adaptedGs</i>[1])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">4</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">3</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td align="left" colspan="13">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 2 (<em>qsBc</em>[A]=<i>adaptedGs</i>[3])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">5</td><td bgcolor="white">1</td><td bgcolor="white">8</td><td bgcolor="white">4</td><td bgcolor="white">7</td><td bgcolor="white">3</td><td bgcolor="white">6</td><td bgcolor="white">2</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 9 (<em>qsBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="15" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="8">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 7 (<em>qsBc</em>[C])</p><p>The Optimal Mismatch algorithm performs 15 character comparisons on the example.</p></p></p>', '2013-05-01 10:05:30', '2013-05-01 10:12:36', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(60, 'Maximal Shift', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Sunday designed an algorithm where the pattern characters are scanned from the one which will lead to a larger shift to the one which will lead to a shorter shift. Doing so one may hope to maximize the lengths of the shifts.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Maximal Shift algorithm consists in sorting the pattern characters in decreasing order of their shift and then in building the Quick Search bad-character shift function (see chapter&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node19.html#SECTION00190" style="text-decoration: underline; color: black;">Quick Search</a>&nbsp;algorithm) and a good-suffix shift function adapted to the scanning order of the pattern characters. It can be done in&nbsp;<big><i><b>O</b></i></big>(<i>m</i><sup>2</sup>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">) time and&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">) space complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the Maximal Shift algorithm has a quadratic worst case time complexity.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">variant of the Quick Search algorithm;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">quadratic worst case time complexity;</span><br></li><li><font color="#000000" face="Times New Roman" size="3" style="line-height: normal;">preprocessing phase in&nbsp;</font><big style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i><b>O</b></i></big><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">(</span><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">m</i><sup style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';">2</sup><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">) time and</span><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">&nbsp;</span><big style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i><b>O</b></i></big><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">(</span><i style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">m</i><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="line-height: normal; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">) space complexity.</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(mn) time complexity.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Maximal Shift algorithm tables" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/mstab1.png"><br clear="all"><span style="white-space: nowrap;">Tables used by Maximal Shift algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><div><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="20">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="16" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 1 (<em>qsBc</em>[G]=<i>adaptedGs</i>[0])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="4" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="19">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="6" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="17">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 2 (<em>qsBc</em>[A])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fourth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">8</td><td bgcolor="white">7</td><td bgcolor="white">2</td><td bgcolor="white">1</td><td bgcolor="white">6</td><td bgcolor="white">5</td><td bgcolor="white">4</td><td bgcolor="white">3</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 9 (<em>qsBc</em>[T])</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Fifth attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="17" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="6">&nbsp;</td></tr><tr><td colspan="14" bgcolor="white">&nbsp;</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="2" bgcolor="white">&nbsp;</td></tr></tbody></table><p style="text-align: start;">Shift by: 7 (<em>qsBc</em>[C])</p><p style="text-align: start;">The Maximal Shift algorithm performs 12 character comparisons on the example.</p></div></p>', '2013-05-01 10:16:14', '2013-05-01 10:18:23', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(61, 'Skip Search', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For each character of the alphabet, a bucket collects all the positions of that character in&nbsp;<i>x</i>. When a character occurs&nbsp;<i>k</i>&nbsp;times in the pattern, there are&nbsp;<i>k</i>&nbsp;corresponding positions in the bucket of the character. When the word is much shorter than the alphabet, many buckets are empty.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Skip Search algorithm consists in computing the buckets for all the characters of the alphabet: for&nbsp;<i>c</i>&nbsp;in&nbsp;<img alt="Sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/gsigma.gif">&nbsp;&nbsp;<i>z</i>[<i>c</i>] = {<i>i</i>&nbsp;<big>:</big>&nbsp; 0&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>-1 and&nbsp;<i>x</i>[<i>i</i>] =&nbsp;<i>c</i>} The space and time complexity of this preprocessing phase is&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The main loop of the search phase consists in examining every&nbsp;<i>m</i>-<i>th</i>&nbsp;text character,&nbsp;<i>y</i>[<i>j</i>] (so there will be&nbsp;<span style="white-space: nowrap;"><i>n</i>&nbsp;/&nbsp;<i>m</i></span>&nbsp;main iterations). For&nbsp;<i>y</i>[<i>j</i>], it uses each position in the bucket&nbsp;<i>z</i>[<i>y</i>[<i>j</i>]] to obtain a possible starting position&nbsp;<i>p</i>&nbsp;of&nbsp;<i>x</i>&nbsp;in&nbsp;<i>y</i>. It performs a comparison of&nbsp;<i>x</i>&nbsp;with&nbsp;<i>y</i>&nbsp;beginning at position&nbsp;<i>p</i>, character by character, until there is a mismatch, or until all match.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The Skip Search algorithm has a quadratic worst case time complexity but the expected number of text character inspections is&nbsp;<big><i><b>O</b></i></big>(<i>n</i>).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><ul><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">uses buckets of positions for each character of the alphabet;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">preprocessing phase in&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">)&nbsp;time and space complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">searching phase in O(mn) time complexity;</span><br></li><li><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium; line-height: normal;">O(n) expected text character comparisons.</span><br></li></ul></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Skip search Z table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/sksztab1.png"><br clear="all"><span style="white-space: nowrap;">Z table used by Skip Search algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 8</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="13" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="10">&nbsp;</td></tr></tbody></table><p>Shift by: 8</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td></tr></tbody></table><p>The Skip Search algorithm performs 14 character comparisons on the example.</p></p></p>', '2013-05-01 10:18:42', '2013-05-01 10:20:55', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(62, 'KMP Skip Search', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">It is possible to make the Skip Search algorithm&nbsp;linear using the two shift tables of Morris-Pratt&nbsp;and Knuth-Morris-Pratt.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For 1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>m</i>,&nbsp;<em>mpNext</em>[<i>i</i>] is equal to the length of the longest border of&nbsp;<i>x</i>[0 ..&nbsp;<i>i</i>-1] and&nbsp;<em>mpNext</em>[0]=-1.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">For 1&nbsp;<img alt="leq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/leq.gif">&nbsp;<i>i</i>&nbsp;&lt;&nbsp;<i>m</i>,&nbsp;<em>kmpNext</em>[<i>i</i>] is equal to length of the longest border of&nbsp;<i>x</i>[0 ..&nbsp;<i>i</i>-1] followed by a character different from&nbsp;<i>x</i>[<i>i</i>],&nbsp;<em>kmpNext</em>[0]=-1 and&nbsp;<em>kmpNext</em>[<i>m</i>]=<i>m</i>-<em>per</em>(<i>x</i>).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The lists in the buckets are explicitly stored in a table&nbsp;<em>list</em>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the KmpSkip Search algorithm is in&nbsp;<big><i><b>O</b></i></big>(<i>m</i>+<img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif">) time and space complexity.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>A general situation for an attempt during the searching phase is the following ((see figure&nbsp;<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node32.html#figsit" style="color: rgb(0, 0, 139);">30.1</a>):</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>j</i>&nbsp;is the current text position;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>x</i>[<i>i</i>] =&nbsp;<i>y</i>[<i>j</i>];</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>start</em>&nbsp;=&nbsp;<i>j</i>-<i>i</i>&nbsp;is the possible starting position of an occurrence of&nbsp;<i>x</i>&nbsp;in&nbsp;<i>y</i>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>wall</em>&nbsp;is the rightmost scanned text position;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><i>x</i>[0 ..&nbsp;<em>wall</em>-<em>start</em>-1] =&nbsp;<i>y</i>[<em>start</em>&nbsp;..&nbsp;<em>wall</em>-1];</td></tr></tbody></table></dd></dl><p align="center" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><a id="figsit" name="figsit" style="text-decoration: underline;">&nbsp;</a>&nbsp;<img width="560" height="109" align="BOTTOM" alt="figure 30.1" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/kmpsks1.gif"><br clear="all"><strong>Figure 30.1:</strong>&nbsp;General situation during the searching phase of the linear algorithm.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The comparisons are performed from left to right between&nbsp;<i>x</i>[<em>wall</em>-<em>start</em>&nbsp;..&nbsp;<i>m</i>-1] and&nbsp;<i>y</i>[<em>wall</em>&nbsp;..&nbsp;<em>start</em>+<i>m</i>-1] until a mismatch or a whole match occurs. Let&nbsp;<i>k</i>&nbsp;<img alt="geq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/geq.gif">&nbsp;<em>wall</em>-<em>start</em>&nbsp;be the smallest integer such that<i>x</i>[<i>k</i>]&nbsp;<img alt="neq" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/neq.gif">&nbsp;<i>y</i>[<em>start</em>+<i>k</i>] or&nbsp;<span style="white-space: nowrap;"><i>k</i>&nbsp;=&nbsp;<i>m</i></span>&nbsp;if an occurrence of&nbsp;<i>x</i>&nbsp;starts at position&nbsp;<em>start</em>&nbsp;in&nbsp;<i>y</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">Then&nbsp;<em>wall</em>&nbsp;takes the value of&nbsp;<em>start</em>+<i>k</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">After that the algorithm KmpSkip computes two shifts (two new starting positions): the first one according to the skip algorithm (see algorithm&nbsp;<tt><big><tt>AdvanceSkip</tt></big></tt>&nbsp;for details), this gives us a starting position&nbsp;<em>skipStart</em>, the second one according to the shift table of Knuth-Morris-Pratt, which gives us another starting position&nbsp;<em>kmpStart</em>.</p><dl style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><dt>Several cases can arise:</dt><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>skipStart</em>&nbsp;&lt;&nbsp;<em>kmpStart</em>&nbsp;then a shift according to the skip algorithm is applied which gives a new value for&nbsp;<em>skipStart</em>, and we have to compare again&nbsp;<em>skipStart</em>&nbsp;and&nbsp;<em>kmpStart</em>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>kmpStart</em>&nbsp;&lt;&nbsp;<em>skipStart</em>&nbsp;&lt;&nbsp;<em>wall</em>&nbsp;then a shift according to the shift table of Morris-Pratt is applied. This gives a new value for&nbsp;<em>kmpStart</em>. We have to compare again&nbsp;<em>skipStart</em>&nbsp;and&nbsp;<em>kmpStart</em>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>skipStart</em>&nbsp;=&nbsp;<em>kmpStart</em>&nbsp;then another attempt can be performed with&nbsp;<em>start</em>&nbsp;=&nbsp;<em>skipStart</em>;</td></tr></tbody></table></dd><dd style="margin-left: 18px;"><table summary="case"><tbody><tr><td valign="BASELINE"><img alt="" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/hand.gif">&nbsp;</td><td valign="TOP"><em>kmpStart</em>&nbsp;&lt;&nbsp;<em>wall</em>&nbsp;&lt;&nbsp;<em>skipStart</em>&nbsp;then another attempt can be performed with&nbsp;<em>start</em>&nbsp;=&nbsp;<em>skipStart</em>.</td></tr></tbody></table></dd></dl><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase of the KmpSkip Search algorithm is in&nbsp;<big><i><b>O</b></i></big>(<i>n</i>) time.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">improvement of the Skip Search algorithm;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">uses buckets of positions for each character of the alphabet;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">preprocessing phase in&nbsp;</font><big style="color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><i><b>O</b></i></big><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">(</span><i style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">m</i><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">+</span><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif" style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">)</span><font color="#000000" face="Times New Roman" size="3">&nbsp;time and space complexity;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">searching phase in O(n) time complexity.</font></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Kmp skip search Z table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/kmpskstab1.png"><br clear="all"><span style="white-space: nowrap;">Tables used by KMP Skip Search algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="gray">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td colspan="1" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td colspan="15" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td colspan="3" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td colspan="13" bgcolor="white">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 8</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="gray">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="13" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td align="left" colspan="10">&nbsp;</td></tr></tbody></table><p>Shift by: 8</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="gray">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">2</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">&nbsp;</td><td bgcolor="white">1</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="gray">G</td></tr></tbody></table><p>The KMP Skip Search algorithm performs 14 character comparisons on the example.</p></p></p>', '2013-05-01 10:20:57', '2013-05-01 10:23:15', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1),
	(63, 'Alpha Skip Search', '', '<p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The preprocessing phase of the Alpha Skip Search algorithm consists in building a trie&nbsp;<em><b>T</b></em>(<i>x</i>) of all the factors of the length&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">=log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub><i>m</i>&nbsp;occurring in the word&nbsp;<i>x</i>. The leaves of&nbsp;<em><b>T</b></em>(<i>x</i>) represent all the factors of length&nbsp;<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">&nbsp;of&nbsp;<i>x</i>. There is then one bucket for each leaf of&nbsp;<em><b>T</b></em>(<i>x</i>) in which is stored the list of positions where the factor, associated to the leaf, occurs in&nbsp;<i>x</i>.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The worst case time of this preprocessing phase is linear if the alphabet size is considered to be a constant.</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The searching phase consists in looking into the buckets of the text factors&nbsp;<i>y</i>[<i>j</i>&nbsp;..&nbsp;<i>j</i>+<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">-1] for all&nbsp;<i>j</i>&nbsp;=&nbsp;<i>k</i>.(<i>m</i>-<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">+1)-1 with the integer&nbsp;<i>k</i>&nbsp;in the interval&nbsp;<i>y</i>[1,<img alt="lfloor" align="MIDDLE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/lfloor.gif">(<i>n</i>-<img alt="ell" align="BASELINE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/ell.gif">) /&nbsp;<i>m</i><img alt="rfloor" align="MIDDLE" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/rfloor.gif">].</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">The worst case time complexity of the searching phase is quadratic but the expected number of text character comparisons is&nbsp;<big><i><b>O</b></i></big>(log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub>(<i>m</i>).(<i>n</i>&nbsp;/ (<i>m</i>-log<sub><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub>(<i>m</i>)))).</p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><br></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Main features:</b></p><p align="justify" style="margin: 2px 6px 6px 12px;"><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">improvement of the Skip Search algorithm;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">uses buckets of positions for each factor of length&nbsp;</font><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">log</span><sub style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub><font color="#000000" face="Times New Roman" size="3">(m) of the pattern;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">preprocessing phase in O(m) time and space complexity;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">searching phase in O(mn) time complexity;</font></p><p align="justify" style="margin: 2px 6px 6px 12px;"><font color="#000000" face="Times New Roman" size="3">O(</font><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">log</span><sub style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub><font color="#000000" face="Times New Roman" size="3">(m).(n / (m-</font><span style="color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;">log</span><sub style="font-size: 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\';"><img alt="sigma" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/psigma.gif"></sub><font color="#000000" face="Times New Roman" size="3">(m)))) expected text character comparisons.</font></p></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b><br></b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><b>Example:</b></p><p align="justify" style="margin: 2px 6px 6px 12px; color: rgb(0, 0, 0); font-family: \'Times New Roman\'; font-size: medium;"><p style="margin: 2px 6px 6px 12px; text-align: start;">Preprocessing phase</p><p align="center" style="margin: 2px 6px 6px 12px;"><img alt="Alpha skip search Z table" align="BOTTOM" src="http://www-igm.univ-mlv.fr/~lecroq/string/images/lsksztab1.png"><br clear="all"><span style="white-space: nowrap;">Z table used by Alpha Skip Search algorithm.</span></p><p style="margin: 2px 6px 6px 12px; text-align: start;">Searching&nbsp;phase</p><p style="margin: 2px 6px 6px 12px; text-align: start;"><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">First attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td align="left" colspan="16">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">4</td><td bgcolor="white">5</td><td bgcolor="white">6</td><td bgcolor="white">7</td><td bgcolor="white">8</td><td align="left" colspan="11">&nbsp;</td></tr><tr><td colspan="5" bgcolor="white">&nbsp;</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td colspan="11" bgcolor="white">&nbsp;</td></tr></tbody></table><p>Shift by: 6</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Second attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="lightgrey">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="11" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td align="left" colspan="10">&nbsp;</td></tr></tbody></table><p>Shift by: 6</p><table border="0" cellspacing="0" cellpadding="5" summary="search"><caption align="left" style="text-align: left; color: maroon; font-size: 1.1em;">Third attempt</caption><tbody><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="17" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">2</td><td bgcolor="white">3</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="24">&nbsp;</td></tr><tr><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">T</td><td bgcolor="gray">A</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">T</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">C</td><td bgcolor="antiquewhite">G</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="white">1</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td bgcolor="white">-</td><td align="left" colspan="4">&nbsp;</td></tr><tr><td colspan="16" bgcolor="white">&nbsp;</td><td bgcolor="gray">G</td><td bgcolor="lightgrey">C</td><td bgcolor="lightgrey">A</td><td bgcolor="lightgrey">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td><td bgcolor="antiquewhite">A</td><td bgcolor="antiquewhite">G</td></tr></tbody></table><p>The Alpha Skip Search algorithm performs 18 character comparisons on the example.</p></p></p>', '2013-05-01 10:23:20', '2013-05-01 10:24:39', NULL, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"', 1);
/*!40000 ALTER TABLE `main_algorithmmodel` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_algorithmmodel_tags
CREATE TABLE IF NOT EXISTS `main_algorithmmodel_tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `algorithmmodel_id` int(11) NOT NULL,
  `tagmodel_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `algorithmmodel_id` (`algorithmmodel_id`,`tagmodel_id`),
  KEY `main_algorithmmodel_tags_1a2fe5e0` (`algorithmmodel_id`),
  KEY `main_algorithmmodel_tags_2dea7227` (`tagmodel_id`),
  CONSTRAINT `algorithmmodel_id_refs_id_2f9bcb5a` FOREIGN KEY (`algorithmmodel_id`) REFERENCES `main_algorithmmodel` (`id`),
  CONSTRAINT `tagmodel_id_refs_id_3884241` FOREIGN KEY (`tagmodel_id`) REFERENCES `main_tagmodel` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=149 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_algorithmmodel_tags: ~119 rows (approximately)
/*!40000 ALTER TABLE `main_algorithmmodel_tags` DISABLE KEYS */;
INSERT INTO `main_algorithmmodel_tags` (`id`, `algorithmmodel_id`, `tagmodel_id`) VALUES
	(21, 21, 12),
	(22, 22, 13),
	(26, 24, 2),
	(41, 24, 3),
	(27, 24, 4),
	(28, 25, 2),
	(30, 25, 3),
	(29, 25, 4),
	(31, 26, 2),
	(33, 26, 3),
	(32, 26, 4),
	(36, 27, 2),
	(37, 27, 3),
	(35, 27, 4),
	(40, 28, 2),
	(39, 28, 3),
	(38, 28, 4),
	(43, 29, 2),
	(44, 29, 3),
	(42, 29, 4),
	(46, 30, 2),
	(47, 30, 3),
	(45, 30, 4),
	(48, 31, 2),
	(50, 31, 3),
	(49, 31, 4),
	(52, 32, 2),
	(53, 32, 3),
	(51, 32, 4),
	(55, 33, 2),
	(56, 33, 3),
	(54, 33, 4),
	(59, 34, 2),
	(60, 34, 3),
	(58, 34, 4),
	(62, 35, 2),
	(63, 35, 3),
	(61, 35, 4),
	(66, 36, 2),
	(67, 36, 3),
	(65, 36, 4),
	(71, 38, 2),
	(70, 38, 3),
	(69, 38, 4),
	(75, 40, 2),
	(76, 40, 3),
	(77, 40, 4),
	(80, 41, 2),
	(79, 41, 3),
	(78, 41, 4),
	(85, 43, 2),
	(86, 43, 3),
	(84, 43, 4),
	(88, 44, 2),
	(89, 44, 3),
	(87, 44, 4),
	(91, 45, 2),
	(92, 45, 3),
	(90, 45, 4),
	(94, 46, 2),
	(95, 46, 3),
	(93, 46, 4),
	(97, 47, 2),
	(98, 47, 3),
	(96, 47, 4),
	(100, 48, 2),
	(101, 48, 3),
	(99, 48, 4),
	(103, 49, 2),
	(104, 49, 3),
	(102, 49, 4),
	(107, 50, 2),
	(108, 50, 3),
	(106, 50, 4),
	(110, 51, 2),
	(111, 51, 3),
	(109, 51, 4),
	(116, 53, 2),
	(117, 53, 3),
	(115, 53, 4),
	(120, 54, 2),
	(121, 54, 3),
	(119, 54, 4),
	(123, 55, 2),
	(124, 55, 3),
	(122, 55, 4),
	(126, 56, 2),
	(127, 56, 3),
	(125, 56, 4),
	(129, 57, 2),
	(130, 57, 3),
	(128, 57, 4),
	(131, 58, 2),
	(132, 58, 3),
	(133, 58, 4),
	(138, 60, 2),
	(139, 60, 3),
	(137, 60, 4),
	(141, 61, 2),
	(142, 61, 3),
	(140, 61, 4),
	(144, 62, 2),
	(145, 62, 3),
	(143, 62, 4),
	(147, 63, 2),
	(148, 63, 3),
	(146, 63, 4);
/*!40000 ALTER TABLE `main_algorithmmodel_tags` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_implementationmodel
CREATE TABLE IF NOT EXISTS `main_implementationmodel` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `date_added` datetime NOT NULL,
  `date_modified` datetime NOT NULL,
  `algorithm_id` int(11) NOT NULL,
  `language_id` int(11) NOT NULL,
  `source` longtext COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  KEY `main_implementationmodel_53012c1e` (`algorithm_id`),
  KEY `main_implementationmodel_7ab48146` (`language_id`),
  CONSTRAINT `language_id_refs_id_158fa1e5` FOREIGN KEY (`language_id`) REFERENCES `main_languagemodel` (`id`),
  CONSTRAINT `algorithm_id_refs_id_7a6f5663` FOREIGN KEY (`algorithm_id`) REFERENCES `main_algorithmmodel` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=66 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_implementationmodel: ~45 rows (approximately)
/*!40000 ALTER TABLE `main_implementationmodel` DISABLE KEYS */;
INSERT INTO `main_implementationmodel` (`id`, `date_added`, `date_modified`, `algorithm_id`, `language_id`, `source`) VALUES
	(21, '2013-04-30 09:07:56', '2013-04-30 09:50:42', 21, 2, 'print "Hello, world!"'),
	(22, '2013-04-30 10:03:21', '2013-04-30 10:04:18', 22, 2, 'import random\n\n\ndef sort(seq):\n    if len(seq) == 1:\n        return seq\n    random.seed()\n    while not is_sorted(seq):\n        if len(seq) == 2:\n            i = 0\n            j = 1\n        else:\n            i = random.randint(0, len(seq) - 2)\n            j = random.randint(i, len(seq) - 1)\n        seq[i], seq[j] = seq[j], seq[i]\n    return seq\n\n\ndef is_sorted(seq):\n    return all(seq[i - 1] <= seq[i] for i in xrange(1, len(seq)))\n'),
	(23, '2013-04-30 10:10:56', '2013-04-30 10:10:56', 22, 35, '<?php\r\n    echo "Hello, world!";\r\n?>'),
	(25, '2013-04-30 10:37:12', '2013-04-30 10:44:38', 24, 3, '#define EOS \'\\0\'\n   \nvoid BF(char *x, int m, char *y, int n) { \n  char *yb; \n  /* Searching */ \n  for (yb = y; *y != EOS; ++y) \n    if (memcmp(x, y, m) == 0) \n      OUTPUT(y - yb);\n}\n\n\n\n\n\n\n\n\n\n\n'),
	(26, '2013-04-30 10:40:55', '2013-04-30 10:57:29', 24, 2, 'def brute_force(pattern, value):\n    m = len(pattern)\n    n = len(value)\n    for j in xrange(n - m + 1):\n      for i in range(m):\n        if x[i] != y[i + j]:\n          break\n         if i >= m:\n            return j\n    return -1'),
	(27, '2013-04-30 10:44:06', '2013-04-30 10:47:54', 25, 3, 'void preAut(char *x, int m, Graph aut) {\n   int i, state, target, oldTarget;\n \n   for (state = getInitial(aut), i = 0; i < m; ++i) {\n      oldTarget = getTarget(aut, state, x[i]);\n      target = newVertex(aut);\n      setTarget(aut, state, x[i], target);\n      copyVertex(aut, target, oldTarget);\n      state = target;\n   }\n   setTerminal(aut, state);\n}\n \n \nvoid AUT(char *x, int m, char *y, int n) {\n   int j, state;\n   Graph aut;\n \n   /* Preprocessing */\n   aut = newAutomaton(m + 1, (m + 1)*ASIZE);\n   preAut(x, m, aut);\n \n   /* Searching */\n   for (state = getInitial(aut), j = 0; j < n; ++j) {\n      state = getTarget(aut, state, y[j]);\n      if (isTerminal(aut, state))\n         OUTPUT(j - m + 1);\n   }\n}'),
	(28, '2013-04-30 10:48:21', '2013-04-30 10:50:09', 26, 3, '#define REHASH(a, b, h) ((((h) - (a)*d) << 1) + (b))\n\nvoid KR(char *x, int m, char *y, int n) {\n   int d, hx, hy, i, j;\n\n   /* Preprocessing */\n   /* computes d = 2^(m-1) with\n      the left-shift operator */\n   for (d = i = 1; i < m; ++i)\n      d = (d<<1);\n\n   for (hy = hx = i = 0; i < m; ++i) {\n      hx = ((hx<<1) + x[i]);\n      hy = ((hy<<1) + y[i]);\n   }\n\n   /* Searching */\n   j = 0;\n   while (j <= n-m) {\n      if (hx == hy && memcmp(x, y + j, m) == 0)\n         OUTPUT(j);\n      hy = REHASH(y[j], y[j + m], hy);\n      ++j;\n   }\n\n}'),
	(29, '2013-04-30 10:50:17', '2013-04-30 10:54:00', 27, 3, 'int preSo(char *x, int m, unsigned int S[]) { \n    unsigned int j, lim; \n    int i; \n    for (i = 0; i < ASIZE; ++i) \n      S[i] = ~0; \n    for (lim = i = 0, j = 1; i < m; ++i, j <<= 1) { \n      S[x[i]] &= ~j; \n      lim |= j; \n    } \n    lim = ~(lim>>1); \n    return(lim); \n  } \n\n  void SO(char *x, int m, char *y, int n) { \n    unsigned int lim, state; \n    unsigned int S[ASIZE]; \n    int j; \n    if (m > WORD) \n      error("SO: Use pattern size <= word size"); \n\n    /* Preprocessing */ \n    lim = preSo(x, m, S); \n\n    /* Searching */ \n    for (state = ~0, j = 0; j < n; ++j) { \n      state = (state<<1) | S[y[j]]; \n      if (state < lim) \n        OUTPUT(j - m + 1); \n    } \n  } \n'),
	(30, '2013-04-30 10:55:18', '2013-04-30 10:56:49', 28, 3, 'void preMp(char *x, int m, int mpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = mpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = mpNext[j];\n      mpNext[++i] = ++j;\n   }\n}\n\n\nvoid MP(char *x, int m, char *y, int n) {\n   int i, j, mpNext[XSIZE];\n\n   /* Preprocessing */\n   preMp(x, m, mpNext);\n\n   /* Searching */\n   i = j = 0;\n   while (j < n) {\n      while (i > -1 && x[i] != y[j])\n         i = mpNext[i];\n      i++;\n      j++;\n      if (i >= m) {\n         OUTPUT(j - i);\n         i = mpNext[i];\n      }\n   }\n}\n'),
	(31, '2013-04-30 10:58:26', '2013-04-30 18:33:24', 29, 3, 'void preKmp(char *x, int m, int kmpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = kmpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = kmpNext[j];\n      i++;\n      j++;\n      if (x[i] == x[j])\n         kmpNext[i] = kmpNext[j];\n      else\n         kmpNext[i] = j;\n   }\n}\n\n\nvoid KMP(char *x, int m, char *y, int n) {\n   int i, j, kmpNext[XSIZE];\n\n   /* Preprocessing */\n   preKmp(x, m, kmpNext);\n\n   /* Searching */\n   i = j = 0;\n   while (j < n) {\n      while (i > -1 && x[i] != y[j])\n         i = kmpNext[i];\n      i++;\n      j++;\n      if (i >= m) {\n         OUTPUT(j - i);\n         i = kmpNext[i];\n      }\n   }\n}\n'),
	(32, '2013-04-30 11:01:23', '2013-04-30 11:04:44', 30, 3, 'int getTransition(char *x, int m, int p, List L[],\n                  char c) {\n   List cell;\n \n   if (p < m - 1 && x[p + 1] == c)\n      return(p + 1);\n   else if (p > -1) {\n      cell = L[p];\n      while (cell != NULL)\n         if (x[cell->element] == c)\n            return(cell->element);\n         else\n            cell = cell->next;\n      return(-1);\n   }\n   else\n      return(-1);\n}\n \n \nvoid setTransition(int p, int q, List L[]) {\n   List cell;\n \n   cell = (List)malloc(sizeof(struct _cell));\n   if (cell == NULL)\n      error("SIMON/setTransition");\n   cell->element = q;\n   cell->next = L[p];\n   L[p] = cell;\n}\n \n \nint preSimon(char *x, int m, List L[]) {\n   int i, k, ell;\n   List cell;\n \n   memset(L, NULL, (m - 2)*sizeof(List));\n   ell = -1;\n   for (i = 1; i < m; ++i) {\n      k = ell;\n      cell = (ell == -1 ? NULL : L[k]);\n      ell = -1;\n      if (x[i] == x[k + 1])\n         ell = k + 1;\n      else\n         setTransition(i - 1, k + 1, L);\n      while (cell != NULL) {\n         k = cell->element;\n         if (x[i] == x[k])\n            ell = k;\n         else\n            setTransition(i - 1, k, L);\n         cell = cell->next;\n      }\n   }\n   return(ell);\n}\n\n\nvoid SIMON(char *x, int m, char *y, int n) {\n   int j, ell, state;\n   List L[XSIZE];\n \n   /* Preprocessing */\n   ell = preSimon(x, m, L);\n \n   /* Searching */\n   for (state = -1, j = 0; j < n; ++j) {\n      state = getTransition(x, m, state, L, y[j]);\n      if (state >= m - 1) {\n         OUTPUT(j - m + 1);\n         state = ell;\n      }\n   }\n}'),
	(33, '2013-04-30 11:05:19', '2013-04-30 11:12:24', 31, 3, 'int preColussi(char *x, int m, int h[], int next[],\n               int shift[]) {\n   int i, k, nd, q, r, s;\n   int hmax[XSIZE], kmin[XSIZE], nhd0[XSIZE], rmin[XSIZE];\n\n   /* Computation of hmax */\n   i = k = 1;\n   do {\n      while (x[i] == x[i - k])\n         i++;\n      hmax[k] = i;\n      q = k + 1;\n      while (hmax[q - k] + k < i) {\n         hmax[q] = hmax[q - k] + k;\n         q++;\n      }\n      k = q;\n      if (k == i + 1)\n         i = k;\n   } while (k <= m);\n\n   /* Computation of kmin */\n   memset(kmin, 0, m*sizeof(int));\n   for (i = m; i >= 1; --i)\n      if (hmax[i] < m)\n         kmin[hmax[i]] = i;\n\n   /* Computation of rmin */\n   for (i = m - 1; i >= 0; --i) {\n      if (hmax[i + 1] == m)\n         r = i + 1;\n      if (kmin[i] == 0)\n         rmin[i] = r;\n      else\n         rmin[i] = 0;\n   }\n\n   /* Computation of h */\n   s = -1;\n   r = m;\n   for (i = 0; i < m; ++i)\n      if (kmin[i] == 0)\n         h[--r] = i;\n      else\n         h[++s] = i;\n   nd = s;\n \n   /* Computation of shift */\n   for (i = 0; i <= nd; ++i)\n      shift[i] = kmin[h[i]];\n   for (i = nd + 1; i < m; ++i)\n      shift[i] = rmin[h[i]];\n   shift[m] = rmin[0];\n\n   /* Computation of nhd0 */\n   s = 0;\n   for (i = 0; i < m; ++i) {\n      nhd0[i] = s;\n      if (kmin[i] > 0)\n         ++s;\n   }\n\n\n   /* Computation of next */\n   for (i = 0; i <= nd; ++i)\n      next[i] = nhd0[h[i] - kmin[h[i]]];\n   for (i = nd + 1; i < m; ++i)\n      next[i] = nhd0[m - rmin[h[i]]];\n   next[m] = nhd0[m - rmin[h[m - 1]]];\n\n   return(nd);\n}\n\nvoid COLUSSI(char *x, int m, char *y, int n) {\n   int i, j, last, nd,\n       h[XSIZE], next[XSIZE], shift[XSIZE];\n\n   /* Processing */\n   nd = preColussi(x, m, h, next, shift);\n\n   /* Searching */\n   i = j = 0;\n   last = -1;\n   while (j <= n - m) {\n      while (i < m && last < j + h[i] &&\n                      x[h[i]] == y[j + h[i]])\n         i++;\n      if (i >= m || last >= j + h[i]) {\n         OUTPUT(j);\n         i = m;\n      }\n      if (i > nd)\n         last = j + m - 1;\n      j += shift[i];\n      i = next[i];\n   }\n}'),
	(34, '2013-04-30 11:12:28', '2013-04-30 11:14:13', 32, 3, 'void GG(char *x, int m, char *y, int n) {\n   int i, j, k, ell, last, nd;\n   int h[XSIZE], next[XSIZE], shift[XSIZE];\n   char heavy;\n \n   for (ell = 0; x[ell] == x[ell + 1]; ell++);\n   if (ell == m - 1)\n      /* Searching for a power of a single character */\n      for (j = ell = 0; j < n; ++j)\n          if (x[0] == y[j]) {\n             ++ell;\n             if (ell >= m)\n                OUTPUT(j - m + 1);\n          }\n          else\n             ell = 0;\n   else {\n      /* Preprocessing */\n      nd = preCOLUSSI(x, m, h, next, shift);\n\n      /* Searching */\n      i = j = heavy = 0;\n      last = -1;\n      while (j <= n - m) {\n         if (heavy && i == 0) {\n            k = last - j + 1;\n            while (x[0] == y[j + k])\n               k++;\n            if (k <= ell || x[ell + 1] != y[j + k]) {\n               i = 0;\n               j += (k + 1);\n               last = j - 1;\n            }\n            else {\n               i = 1;\n               last = j + k;\n               j = last - (ell + 1);\n            }\n            heavy = 0;\n         }\n         else {\n            while (i < m && last < j + h[i] &&\n                            x[h[i]] == y[j + h[i]])\n               ++i;\n            if (i >= m || last >= j + h[i]) {\n               OUTPUT(j);\n               i = m;\n            }\n            if (i > nd)\n               last = j + m - 1;\n            j += shift[i];\n            i = next[i];\n         }\n         heavy = (j > last ? 0 : 1);\n      }\n   }\n}'),
	(35, '2013-04-30 11:14:55', '2013-04-30 11:22:53', 33, 3, 'void preKmp(char *x, int m, int kmpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = kmpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = kmpNext[j];\n      i++;\n      j++;\n      if (x[i] == x[j])\n         kmpNext[i] = kmpNext[j];\n      else\n         kmpNext[i] = j;\n   }\n}\n\nvoid AXAMAC(char *x, int m, char *y, int n) {\n   int i, j, k, ell, kmpNext[XSIZE];\n\n   /* Preprocessing */\n   preKmp(x, m, kmpNext);\n   for (ell = 1; x[ell - 1] == x[ell]; ell++);\n   if (ell == m)\n      ell = 0;\n\n   /* Searching */\n   i = ell;\n   j = k = 0;\n   while (j <= n - m) {\n      while (i < m && x[i] == y[i + j])\n         ++i;\n      if (i >= m) {\n         while (k < ell && x[k] == y[j + k])\n            ++k;\n         if (k >= ell)\n            OUTPUT(j);\n      }\n      j += (i - kmpNext[i]);\n      if (i == ell)\n         k = MAX(0, k - 1);\n      else\n         if (kmpNext[i] <= ell) {\n            k = MAX(0, kmpNext[i]);\n            i = ell;\n         }\n         else {\n            k = ell;\n            i = kmpNext[i];\n         }\n   }\n}'),
	(36, '2013-04-30 11:23:21', '2013-04-30 11:24:55', 34, 3, 'void NSN(char *x, int m, char *y, int n) {\n   int j, k, ell;\n  \n   /* Preprocessing */\n   if (x[0] == x[1]) {\n      k = 2;\n      ell = 1;\n   }\n   else {\n      k = 1;\n      ell = 2;\n   }\n  \n   /* Searching */\n   j = 0;\n   while (j <= n - m)\n      if (x[1] != y[j + 1])\n         j += k;\n      else {\n         if (memcmp(x + 2, y + j + 2, m - 2) == 0 &&\n             x[0] == y[j])\n            OUTPUT(j);\n         j += ell;\n      }\n}'),
	(37, '2013-04-30 11:25:56', '2013-04-30 11:30:31', 35, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n \n \nvoid suffixes(char *x, int m, int *suff) {\n   int f, g, i;\n \n   suff[m - 1] = m;\n   g = m - 1;\n   for (i = m - 2; i >= 0; --i) {\n      if (i > g && suff[i + m - 1 - f] < i - g)\n         suff[i] = suff[i + m - 1 - f];\n      else {\n         if (i < g)\n            g = i;\n         f = i;\n         while (g >= 0 && x[g] == x[g + m - 1 - f])\n            --g;\n         suff[i] = f - g;\n      }\n   }\n}\n \nvoid preBmGs(char *x, int m, int bmGs[]) {\n   int i, j, suff[XSIZE];\n \n   suffixes(x, m, suff);\n \n   for (i = 0; i < m; ++i)\n      bmGs[i] = m;\n   j = 0;\n   for (i = m - 1; i >= 0; --i)\n      if (suff[i] == i + 1)\n         for (; j < m - 1 - i; ++j)\n            if (bmGs[j] == m)\n               bmGs[j] = m - 1 - i;\n   for (i = 0; i <= m - 2; ++i)\n      bmGs[m - 1 - suff[i]] = m - 1 - i;\n}\n \n \nvoid BM(char *x, int m, char *y, int n) {\n   int i, j, bmGs[XSIZE], bmBc[ASIZE];\n \n   /* Preprocessing */\n   preBmGs(x, m, bmGs);\n   preBmBc(x, m, bmBc);\n \n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      for (i = m - 1; i >= 0 && x[i] == y[i + j]; --i);\n      if (i < 0) {\n         OUTPUT(j);\n         j += bmGs[0];\n      }\n      else\n         j += MAX(bmGs[i], bmBc[y[i + j]] - m + 1 + i);\n   }\n}\n   '),
	(38, '2013-04-30 11:30:41', '2013-04-30 11:34:41', 36, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n\nvoid suffixes(char *x, int m, int *suff) {\n   int f, g, i;\n \n   suff[m - 1] = m;\n   g = m - 1;\n   for (i = m - 2; i >= 0; --i) {\n      if (i > g && suff[i + m - 1 - f] < i - g)\n         suff[i] = suff[i + m - 1 - f];\n      else {\n         if (i < g)\n            g = i;\n         f = i;\n         while (g >= 0 && x[g] == x[g + m - 1 - f])\n            --g;\n         suff[i] = f - g;\n      }\n   }\n}\n \nvoid preBmGs(char *x, int m, int bmGs[]) {\n   int i, j, suff[XSIZE];\n \n   suffixes(x, m, suff);\n \n   for (i = 0; i < m; ++i)\n      bmGs[i] = m;\n   j = 0;\n   for (i = m - 1; i >= 0; --i)\n      if (suff[i] == i + 1)\n         for (; j < m - 1 - i; ++j)\n            if (bmGs[j] == m)\n               bmGs[j] = m - 1 - i;\n   for (i = 0; i <= m - 2; ++i)\n      bmGs[m - 1 - suff[i]] = m - 1 - i;\n}\n\nvoid TBM(char *x, int m, char *y, int n) {\n   int bcShift, i, j, shift, u, v, turboShift,\n       bmGs[XSIZE], bmBc[ASIZE];\n\n   /* Preprocessing */\n   preBmGs(x, m, bmGs);\n   preBmBc(x, m, bmBc);\n\n   /* Searching */\n   j = u = 0;\n   shift = m;\n   while (j <= n - m) {\n      i = m - 1;\n      while (i >= 0 && x[i] == y[i + j]) {\n         --i;\n         if (u != 0 && i == m - 1 - shift)\n            i -= u;\n      }\n      if (i < 0) {\n         OUTPUT(j);\n         shift = bmGs[0];\n         u = m - shift;\n      }\n      else {\n         v = m - 1 - i;\n         turboShift = u - v;\n         bcShift = bmBc[y[i + j]] - m + 1 + i;\n         shift = MAX(turboShift, bcShift);\n         shift = MAX(shift, bmGs[i]);\n         if (shift == bmGs[i])\n            u = MIN(m - shift, v);\n         else {\n           if (turboShift < bcShift)\n              shift = MAX(shift, u + 1);\n           u = 0;\n         }\n      }\n      j += shift;\n   }\n}\n'),
	(40, '2013-05-01 06:47:31', '2013-05-01 09:07:50', 38, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n \n \nvoid suffixes(char *x, int m, int *suff) {\n   int f, g, i;\n \n   suff[m - 1] = m;\n   g = m - 1;\n   for (i = m - 2; i >= 0; --i) {\n      if (i > g && suff[i + m - 1 - f] < i - g)\n         suff[i] = suff[i + m - 1 - f];\n      else {\n         if (i < g)\n            g = i;\n         f = i;\n         while (g >= 0 && x[g] == x[g + m - 1 - f])\n            --g;\n         suff[i] = f - g;\n      }\n   }\n}\n \nvoid preBmGs(char *x, int m, int bmGs[]) {\n   int i, j, suff[XSIZE];\n \n   suffixes(x, m, suff);\n \n   for (i = 0; i < m; ++i)\n      bmGs[i] = m;\n   j = 0;\n   for (i = m - 1; i >= 0; --i)\n      if (suff[i] == i + 1)\n         for (; j < m - 1 - i; ++j)\n            if (bmGs[j] == m)\n               bmGs[j] = m - 1 - i;\n   for (i = 0; i <= m - 2; ++i)\n      bmGs[m - 1 - suff[i]] = m - 1 - i;\n}\n\nvoid AG(char *x, int m, char *y, int n) {\n   int i, j, k, s, shift,\n       bmGs[XSIZE], skip[XSIZE], suff[XSIZE], bmBc[ASIZE];\n  \n   /* Preprocessing */\n   preBmGs(x, m, bmGs, suff);\n   preBmBc(x, m, bmBc);\n   memset(skip, 0, m*sizeof(int));\n  \n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = m - 1;\n      while (i >= 0) {\n         k = skip[i];\n         s = suff[i];\n         if (k > 0)\n            if (k > s) {\n               if (i + 1 == s)\n                  i = (-1);\n               else\n                  i -= s;\n               break;\n            }\n            else {\n               i -= k;\n               if (k < s)\n                  break;\n            }\n         else {\n            if (x[i] == y[i + j])\n               --i;\n            else\n               break;\n         }\n      }\n      if (i < 0) {\n         OUTPUT(j);\n         skip[m - 1] = m;\n         shift = bmGs[0];\n      }\n      else {\n         skip[m - 1] = m - 1 - i;\n         shift = MAX(bmGs[i], bmBc[y[i + j]] - m + 1 + i);\n      }\n      j += shift;\n      memcpy(skip, skip + shift, (m - shift)*sizeof(int));\n      memset(skip + m - shift, 0, shift*sizeof(int));\n   }\n}\n'),
	(42, '2013-05-01 09:08:47', '2013-05-01 09:14:20', 40, 3, 'void preRc(char *x, int m, int h[],\n           int rcBc[ASIZE][XSIZE], int rcGs[]) {\n   int a, i, j, k, q, r, s,\n       hmin[XSIZE], kmin[XSIZE], link[XSIZE], \n       locc[ASIZE], rmin[XSIZE];\n \n   /* Computation of link and locc */\n   for (a = 0; a < ASIZE; ++a)\n      locc[a] = -1;\n   link[0] = -1;\n   for (i = 0; i < m - 1; ++i) {\n      link[i + 1] = locc[x[i]];\n      locc[x[i]] = i;\n   }\n \n   /* Computation of rcBc */\n   for (a = 0; a < ASIZE; ++a)\n      for (s = 1; s <= m; ++s) {\n         i = locc[a];\n         j = link[m - s];\n         while (i - j != s && j >= 0)\n            if (i - j > s)\n               i = link[i + 1];\n            else\n               j = link[j + 1];\n         while (i - j > s)\n            i = link[i + 1];\n         rcBc[a][s] = m - i - 1;\n      }\n \n   /* Computation of hmin */\n   k = 1;\n   i = m - 1;\n   while (k <= m) {\n      while (i - k >= 0 && x[i - k] == x[i])\n         --i;\n      hmin[k] = i;\n      q = k + 1;\n      while (hmin[q - k] - (q - k) > i) {\n         hmin[q] = hmin[q - k];\n         ++q;\n      }\n      i += (q - k);\n      k = q;\n      if (i == m)\n         i = m - 1;\n   }\n \n   /* Computation of kmin */\n   memset(kmin, 0, m * sizeof(int));\n   for (k = m; k > 0; --k)\n      kmin[hmin[k]] = k;\n \n   /* Computation of rmin */\n   for (i = m - 1; i >= 0; --i) {\n      if (hmin[i + 1] == i)\n         r = i + 1;\n      rmin[i] = r;\n   }\n \n   /* Computation of rcGs */\n   i = 1;\n   for (k = 1; k <= m; ++k)\n      if (hmin[k] != m - 1 && kmin[hmin[k]] == k) {\n         h[i] = hmin[k];\n         rcGs[i++] = k;\n      }\n   i = m-1;\n   for (j = m - 2; j >= 0; --j)\n      if (kmin[j] == 0) {\n         h[i] = j;\n         rcGs[i--] = rmin[j];\n      }\n   rcGs[m] = rmin[0];\n}\n \n \nvoid RC(char *x, int m, char *y, int n) {\n   int i, j, s, rcBc[ASIZE][XSIZE], rcGs[XSIZE], h[XSIZE];\n \n   /* Preprocessing */\n   preRc(x, m, h, rcBc, rcGs);\n \n   /* Searching */\n   j = 0;\n   s = m;\n   while (j <= n - m) {\n      while (j <= n - m && x[m - 1] != y[j + m - 1]) {\n         s = rcBc[y[j + m - 1]][s];\n         j += s;\n      }\n      for (i = 1; i < m && x[h[i]] == y[j + h[i]]; ++i);\n      if (i >= m)\n         OUTPUT(j);\n      s = rcGs[i];\n      j += s;\n   }\n}'),
	(43, '2013-05-01 09:10:23', '2013-05-01 09:13:11', 41, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n \n \nvoid suffixes(char *x, int m, int *suff) {\n   int f, g, i;\n \n   suff[m - 1] = m;\n   g = m - 1;\n   for (i = m - 2; i >= 0; --i) {\n      if (i > g && suff[i + m - 1 - f] < i - g)\n         suff[i] = suff[i + m - 1 - f];\n      else {\n         if (i < g)\n            g = i;\n         f = i;\n         while (g >= 0 && x[g] == x[g + m - 1 - f])\n            --g;\n         suff[i] = f - g;\n      }\n   }\n}\n \nvoid preBmGs(char *x, int m, int bmGs[]) {\n   int i, j, suff[XSIZE];\n \n   suffixes(x, m, suff);\n \n   for (i = 0; i < m; ++i)\n      bmGs[i] = m;\n   j = 0;\n   for (i = m - 1; i >= 0; --i)\n      if (suff[i] == i + 1)\n         for (; j < m - 1 - i; ++j)\n            if (bmGs[j] == m)\n               bmGs[j] = m - 1 - i;\n   for (i = 0; i <= m - 2; ++i)\n      bmGs[m - 1 - suff[i]] = m - 1 - i;\n}\n\nvoid HORSPOOL(char *x, int m, char *y, int n) {\n   int j, bmBc[ASIZE];\n   char c;\n\n   /* Preprocessing */\n   preBmBc(x, m, bmBc);\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      c = y[j + m - 1];\n      if (x[m - 1] == c && memcmp(x, y + j, m - 1) == 0)\n         OUTPUT(j);\n      j += bmBc[c];\n   }\n}'),
	(45, '2013-05-01 09:16:44', '2013-05-01 09:18:33', 43, 3, 'void preQsBc(char *x, int m, int qsBc[]) {\n   int i;\n\n   for (i = 0; i < ASIZE; ++i)\n      qsBc[i] = m + 1;\n   for (i = 0; i < m; ++i)\n      qsBc[x[i]] = m - i;\n}\n\n\nvoid QS(char *x, int m, char *y, int n) {\n   int j, qsBc[ASIZE];\n\n   /* Preprocessing */\n   preQsBc(x, m, qsBc);\n \n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      if (memcmp(x, y + j, m) == 0)\n         OUTPUT(j);\n      j += qsBc[y[j + m]];               /* shift */\n   }\n}'),
	(46, '2013-05-01 09:19:40', '2013-05-01 09:22:05', 44, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n\nvoid TUNEDBM(char *x, int m, char *y, int n) {\n   int j, k, shift, bmBc[ASIZE];\n \n   /* Preprocessing */\n   preBmBc(x, m, bmBc);\n   shift = bmBc[x[m - 1]];\n   bmBc[x[m - 1]] = 0;\n   memset(y + n, x[m - 1], m);\n \n   /* Searching */\n   j = 0;\n   while (j < n) {\n      k = bmBc[y[j + m -1]];\n      while (k !=  0) {\n         j += k; k = bmBc[y[j + m -1]];\n         j += k; k = bmBc[y[j + m -1]];\n         j += k; k = bmBc[y[j + m -1]];\n      }\n      if (memcmp(x, y + j, m - 1) == 0 && j < n)\n         OUTPUT(j);\n      j += shift;                          /* shift */\n   }\n}'),
	(47, '2013-05-01 09:22:20', '2013-05-01 09:24:24', 45, 3, 'void suffixes(char *x, int m, int *suff) {\n   int f, g, i;\n \n   suff[m - 1] = m;\n   g = m - 1;\n   for (i = m - 2; i >= 0; --i) {\n      if (i > g && suff[i + m - 1 - f] < i - g)\n         suff[i] = suff[i + m - 1 - f];\n      else {\n         if (i < g)\n            g = i;\n         f = i;\n         while (g >= 0 && x[g] == x[g + m - 1 - f])\n            --g;\n         suff[i] = f - g;\n      }\n   }\n}\n \nvoid preBmGs(char *x, int m, int bmGs[]) {\n   int i, j, suff[XSIZE];\n \n   suffixes(x, m, suff);\n \n   for (i = 0; i < m; ++i)\n      bmGs[i] = m;\n   j = 0;\n   for (i = m - 1; i >= 0; --i)\n      if (suff[i] == i + 1)\n         for (; j < m - 1 - i; ++j)\n            if (bmGs[j] == m)\n               bmGs[j] = m - 1 - i;\n   for (i = 0; i <= m - 2; ++i)\n      bmGs[m - 1 - suff[i]] = m - 1 - i;\n}\n\n void preZtBc(char *x, int m, int ztBc[ASIZE][ASIZE]) {\n   int i, j;\n\n   for (i = 0; i < ASIZE; ++i)\n      for (j = 0; j < ASIZE; ++j)\n         ztBc[i][j] = m;\n   for (i = 0; i < ASIZE; ++i)\n      ztBc[i][x[0]] = m - 1;\n   for (i = 1; i < m - 1; ++i)\n      ztBc[x[i - 1]][x[i]] = m - 1 - i;\n}\n\n\nvoid ZT(char *x, int m, char *y, int n) {\n   int i, j, ztBc[ASIZE][ASIZE], bmGs[XSIZE];\n\n   /* Preprocessing */\n   preZtBc(x, m, ztBc);\n   preBmGs(x, m, bmGs);\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = m - 1;\n      while (i < m && x[i] == y[i + j])\n         --i;\n      if (i < 0) {\n         OUTPUT(j);\n         j += bmGs[0];\n      }\n      else\n         j += MAX(bmGs[i],\n                  ztBc[y[j + m - 2]][y[j + m - 1]]);\n   }\n}'),
	(48, '2013-05-01 09:24:38', '2013-05-01 09:25:53', 46, 3, 'void preBrBc(char *x, int m, int brBc[ASIZE][ASIZE]) {\n   int a, b, i;\n\n   for (a = 0; a < ASIZE; ++a)\n      for (b = 0; b < ASIZE; ++b)\n         brBc[a][b] = m + 2;\n   for (a = 0; a < ASIZE; ++a)\n      brBc[a][x[0]] = m + 1;\n   for (i = 0; i < m - 1; ++i)\n      brBc[x[i]][x[i + 1]] = m - i;\n   for (a = 0; a < ASIZE; ++a)\n      brBc[x[m - 1]][a] = 1;\n}\n\n\nvoid BR(char *x, int m, char *y, int n) {\n   int j, brBc[ASIZE][ASIZE];\n\n   /* Preprocessing */\n   preBrBc(x, m, brBc);\n\n   /* Searching */\n   y[n + 1] = \'\\0\';\n   j = 0;\n   while (j <= n - m) {\n      if (memcmp(x, y + j, m) == 0)\n         OUTPUT(j);\n      j += brBc[y[j + m]][y[j + m + 1]];\n   }\n}'),
	(49, '2013-05-01 09:25:59', '2013-05-01 09:27:41', 47, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n\nvoid preQsBc(char *x, int m, int qsBc[]) {\n   int i;\n\n   for (i = 0; i < ASIZE; ++i)\n      qsBc[i] = m + 1;\n   for (i = 0; i < m; ++i)\n      qsBc[x[i]] = m - i;\n}\n\nvoid SMITH(char *x, int m, char *y, int n) {\n   int j, bmBc[ASIZE], qsBc[ASIZE];\n\n   /* Preprocessing */\n   preBmBc(x, m, bmBc);\n   preQsBc(x, m, qsBc);\n\n   /* Searching */\n   j = 0;\n   while (j<= n - m) {\n      if (memcmp(x, y + j, m) == 0)\n         OUTPUT(j);\n      j += MAX(bmBc[y[j + m - 1]], qsBc[y[j + m]]);\n   }\n}'),
	(50, '2013-05-01 09:27:45', '2013-05-01 09:37:07', 48, 3, 'void preBmBc(char *x, int m, int bmBc[]) {\n   int i;\n \n   for (i = 0; i < ASIZE; ++i)\n      bmBc[i] = m;\n   for (i = 0; i < m - 1; ++i)\n      bmBc[x[i]] = m - i - 1;\n}\n\nvoid RAITA(char *x, int m, char *y, int n) {\n   int j, bmBc[ASIZE];\n   char c, firstCh, *secondCh, middleCh, lastCh;\n\n   /* Preprocessing */\n   preBmBc(x, m, bmBc);\n   firstCh = x[0];\n   secondCh = x + 1;\n   middleCh = x[m/2];\n   lastCh = x[m - 1];\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      c = y[j + m - 1];\n      if (lastCh == c && middleCh == y[j + m/2] &&\n          firstCh == y[j] &&\n          memcmp(secondCh, y + j + 1, m - 2) == 0)\n         OUTPUT(j);\n      j += bmBc[c];\n   }\n}'),
	(51, '2013-05-01 09:37:11', '2013-05-01 09:41:31', 49, 3, '  struct _cell{\n    int element; \n    struct _cell *next;\n  };\n \n  typedef struct _cell *List; \n\nstruct _graph {\n    int vertexNumber, \n        edgeNumber, \n        vertexCounter, \n        initial, \n        *terminal, \n        *target, \n        *suffixLink,\n        *length, \n        *position, \n        *shift; \n  };\n  \n  typedef struct _graph *Graph; \n  typedef int boolean;\n   \n#define UNDEFINED -1\n  \n/* returns a new data structure for\n   a graph with v vertices and e edges */\nGraph newGraph(int v, int e) {\n   Graph g;\n\n   g = (Graph)calloc(1, sizeof(struct _graph));\n   if (g == NULL)\n      error("newGraph");\n   g->vertexNumber  = v;\n   g->edgeNumber    = e;\n   g->initial       = 0;\n   g->vertexCounter = 1;\n   return(g);\n}\n\n\n/* returns a new data structure for\n   a automaton with v vertices and e edges */\nGraph newAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newGraph(v, e);\n   aut->target = (int *)calloc(e, sizeof(int));\n   if (aut->target == NULL)\n      error("newAutomaton");\n   aut->terminal = (int *)calloc(v, sizeof(int));\n   if (aut->terminal == NULL)\n      error("newAutomaton");\n   return(aut);\n}\n\n\n/* returns a new data structure for\n   a suffix automaton with v vertices and e edges */\nGraph newSuffixAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newSuffixAutomaton");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newSuffixAutomaton");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newSuffixAutomaton");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newSuffixAutomaton");\n   return(aut);\n}\n \n \n/* returns a new data structure for\n   a trie with v vertices and e edges */\nGraph newTrie(int v, int e) {\n   Graph aut;\n \n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newTrie");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newTrie");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newTrie");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newTrie");\n   return(aut);\n}\n\n\n/* returns a new vertex for graph g */\nint newVertex(Graph g) {\n   if (g != NULL && g->vertexCounter <= g->vertexNumber)\n      return(g->vertexCounter++);\n   error("newVertex");\n}\n\n\n/* returns the initial vertex of graph g */\nint getInitial(Graph g) {\n   if (g != NULL)\n      return(g->initial);\n   error("getInitial");\n}\n\n\n/* returns true if vertex v is terminal in graph g */\nboolean isTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      return(g->terminal[v]);\n   error("isTerminal");\n}\n\n\n/* set vertex v to be terminal in graph g */\nvoid setTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      g->terminal[v] = 1;\n   else\n      error("isTerminal");\n}\n\n\n/* returns the target of edge from vertex v\n   labelled by character c in graph g */\nint getTarget(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->target[v*(g->edgeNumber/g->vertexNumber) +\n                       c]);\n   error("getTarget");\n}\n\n\n/* add the edge from vertex v to vertex t\n   labelled by character c in graph g */\nvoid setTarget(Graph g, int v, unsigned char c, int t) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber &&\n       v*c <= g->edgeNumber && t < g->vertexNumber)\n      g->target[v*(g->edgeNumber/g->vertexNumber) + c] = t;\n   else\n      error("setTarget");\n}\n\n\n/* returns the suffix link of vertex v in graph g */\nint getSuffixLink(Graph g, int v) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber)\n      return(g->suffixLink[v]);\n   error("getSuffixLink");\n}\n\n\n/* set the suffix link of vertex v\n   to vertex s in graph g */\nvoid setSuffixLink(Graph g, int v, int s) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber && s < g->vertexNumber)\n      g->suffixLink[v] = s;\n   else\n      error("setSuffixLink");\n}\n\n\n/* returns the length of vertex v in graph g */\nint getLength(Graph g, int v) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      return(g->length[v]);\n   error("getLength");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setLength(Graph g, int v, int ell) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      g->length[v] = ell;\n   else\n      error("setLength");\n}\n\n\n/* returns the position of vertex v in graph g */\nint getPosition(Graph g, int v) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      return(g->position[v]);\n   error("getPosition");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setPosition(Graph g, int v, int p) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      g->position[v] = p;\n   else\n      error("setPosition");\n}\n\n\n/* returns the shift of the edge from vertex v\n   labelled by character c in graph g */\nint getShift(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->shift[v*(g->edgeNumber/g->vertexNumber) +\n             c]);\n   error("getShift");\n}\n\n\n/* set the shift of the edge from vertex v\n   labelled by character c to integer s in graph g */\nvoid setShift(Graph g, int v, unsigned char c, int s) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c <= g->edgeNumber)\n      g->shift[v*(g->edgeNumber/g->vertexNumber) + c] = s;\n   else\n      error("setShift");\n}\n\n\n/* copies all the characteristics of vertex source\n   to vertex target in graph g */\nvoid copyVertex(Graph g, int target, int source) {\n   if (g != NULL && target < g->vertexNumber &&\n       source < g->vertexNumber) {\n      if (g->target != NULL)\n         memcpy(g->target +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->target +\n                source*(g->edgeNumber/g->vertexNumber),\n                (g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->shift != NULL)\n         memcpy(g->shift +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->shift +\n                source*(g->edgeNumber/g->vertexNumber),\n                g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->terminal != NULL)\n         g->terminal[target] = g->terminal[source];\n      if (g->suffixLink != NULL)\n         g->suffixLink[target] = g->suffixLink[source];\n      if (g->length != NULL)\n         g->length[target] = g->length[source];\n      if (g->position != NULL)\n         g->position[target] = g->position[source];\n   }\n   else\n      error("copyVertex");\n}\n\nvoid buildSuffixAutomaton(char *x, int m, Graph aut) {\n   int i, art, init, last, p, q, r;\n   char c;\n  \n   init = getInitial(aut);\n   art = newVertex(aut);\n   setSuffixLink(aut, init, art);\n   last = init;\n   for (i = 0; i < m; ++i) {\n      c = x[i];\n      p = last;\n      q = newVertex(aut);\n      setLength(aut, q, getLength(aut, p) + 1);\n      setPosition(aut, q, getPosition(aut, p) + 1);\n      while (p != init &&\n             getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, p, c, q);\n         setShift(aut, p, c, getPosition(aut, q) -\n                             getPosition(aut, p) - 1);\n         p = getSuffixLink(aut, p);\n      }\n      if (getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, init, c, q);\n         setShift(aut, init, c,\n                  getPosition(aut, q) -\n                  getPosition(aut, init) - 1);\n         setSuffixLink(aut, q, init);\n      }\n      else\n         if (getLength(aut, p) + 1 ==\n             getLength(aut, getTarget(aut, p, c)))\n            setSuffixLink(aut, q, getTarget(aut, p, c));\n         else {\n            r = newVertex(aut);\n            copyVertex(aut, r, getTarget(aut, p, c));\n            setLength(aut, r, getLength(aut, p) + 1);\n            setSuffixLink(aut, getTarget(aut, p, c), r);\n            setSuffixLink(aut, q, r);\n            while (p != art &&\n                   getLength(aut, getTarget(aut, p, c)) >=\n                   getLength(aut, r)) {\n               setShift(aut, p, c,\n                        getPosition(aut,\n                                    getTarget(aut, p, c)) -\n                        getPosition(aut, p) - 1);\n               setTarget(aut, p, c, r);\n               p = getSuffixLink(aut, p);\n            }\n         }\n      last = q;\n   }\n   setTerminal(aut, last);\n   while (last != init) {\n      last = getSuffixLink(aut, last);\n      setTerminal(aut, last);\n   }\n}\n\n\nchar *reverse(char *x, int m) {\n   char *xR;\n   int i;\n \n   xR = (char *)malloc((m + 1)*sizeof(char));\n   for (i = 0; i < m; ++i)\n      xR[i] = x[m - 1 - i];\n   xR[m] = \'\\0\';\n   return(xR);\n}\n \n \nint RF(char *x, int m, char *y, int n) {\n   int i, j, shift, period, init, state;\n   Graph aut;\n   char *xR;\n \n   /* Preprocessing */\n   aut = newSuffixAutomaton(2*(m + 2), 2*(m + 2)*ASIZE);\n   xR = reverse(x, m);\n   buildSuffixAutomaton(xR, m, aut);\n   init = getInitial(aut);\n   period = m;\n \n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = m - 1;\n      state = init;\n      shift = m;\n      while (i + j >= 0 &&\n             getTarget(aut, state, y[i + j]) !=\n             UNDEFINED) {\n         state = getTarget(aut, state, y[i + j]);\n         if (isTerminal(aut, state)) {\n            period = shift;\n            shift = i;\n         }\n         --i;\n      }\n      if (i < 0) {\n         OUTPUT(j);\n         shift = period;\n      }\n      j += shift;\n   }\n}'),
	(52, '2013-05-01 09:41:57', '2013-05-01 09:45:12', 50, 3, ' struct _cell{\n    int element; \n    struct _cell *next;\n  };\n \n  typedef struct _cell *List;\n    \n  struct _graph {\n    int vertexNumber, \n        edgeNumber, \n        vertexCounter, \n        initial, \n        *terminal, \n        *target, \n        *suffixLink,\n        *length, \n        *position, \n        *shift; \n  };\n  \n  typedef struct _graph *Graph; \n  typedef int boolean;\n   \n#define UNDEFINED -1\n  \n/* returns a new data structure for\n   a graph with v vertices and e edges */\nGraph newGraph(int v, int e) {\n   Graph g;\n\n   g = (Graph)calloc(1, sizeof(struct _graph));\n   if (g == NULL)\n      error("newGraph");\n   g->vertexNumber  = v;\n   g->edgeNumber    = e;\n   g->initial       = 0;\n   g->vertexCounter = 1;\n   return(g);\n}\n\n\n/* returns a new data structure for\n   a automaton with v vertices and e edges */\nGraph newAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newGraph(v, e);\n   aut->target = (int *)calloc(e, sizeof(int));\n   if (aut->target == NULL)\n      error("newAutomaton");\n   aut->terminal = (int *)calloc(v, sizeof(int));\n   if (aut->terminal == NULL)\n      error("newAutomaton");\n   return(aut);\n}\n\n\n/* returns a new data structure for\n   a suffix automaton with v vertices and e edges */\nGraph newSuffixAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newSuffixAutomaton");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newSuffixAutomaton");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newSuffixAutomaton");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newSuffixAutomaton");\n   return(aut);\n}\n \n \n/* returns a new data structure for\n   a trie with v vertices and e edges */\nGraph newTrie(int v, int e) {\n   Graph aut;\n \n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newTrie");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newTrie");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newTrie");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newTrie");\n   return(aut);\n}\n\n\n/* returns a new vertex for graph g */\nint newVertex(Graph g) {\n   if (g != NULL && g->vertexCounter <= g->vertexNumber)\n      return(g->vertexCounter++);\n   error("newVertex");\n}\n\n\n/* returns the initial vertex of graph g */\nint getInitial(Graph g) {\n   if (g != NULL)\n      return(g->initial);\n   error("getInitial");\n}\n\n\n/* returns true if vertex v is terminal in graph g */\nboolean isTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      return(g->terminal[v]);\n   error("isTerminal");\n}\n\n\n/* set vertex v to be terminal in graph g */\nvoid setTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      g->terminal[v] = 1;\n   else\n      error("isTerminal");\n}\n\n\n/* returns the target of edge from vertex v\n   labelled by character c in graph g */\nint getTarget(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->target[v*(g->edgeNumber/g->vertexNumber) +\n                       c]);\n   error("getTarget");\n}\n\n\n/* add the edge from vertex v to vertex t\n   labelled by character c in graph g */\nvoid setTarget(Graph g, int v, unsigned char c, int t) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber &&\n       v*c <= g->edgeNumber && t < g->vertexNumber)\n      g->target[v*(g->edgeNumber/g->vertexNumber) + c] = t;\n   else\n      error("setTarget");\n}\n\n\n/* returns the suffix link of vertex v in graph g */\nint getSuffixLink(Graph g, int v) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber)\n      return(g->suffixLink[v]);\n   error("getSuffixLink");\n}\n\n\n/* set the suffix link of vertex v\n   to vertex s in graph g */\nvoid setSuffixLink(Graph g, int v, int s) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber && s < g->vertexNumber)\n      g->suffixLink[v] = s;\n   else\n      error("setSuffixLink");\n}\n\n\n/* returns the length of vertex v in graph g */\nint getLength(Graph g, int v) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      return(g->length[v]);\n   error("getLength");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setLength(Graph g, int v, int ell) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      g->length[v] = ell;\n   else\n      error("setLength");\n}\n\n\n/* returns the position of vertex v in graph g */\nint getPosition(Graph g, int v) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      return(g->position[v]);\n   error("getPosition");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setPosition(Graph g, int v, int p) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      g->position[v] = p;\n   else\n      error("setPosition");\n}\n\n\n/* returns the shift of the edge from vertex v\n   labelled by character c in graph g */\nint getShift(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->shift[v*(g->edgeNumber/g->vertexNumber) +\n             c]);\n   error("getShift");\n}\n\n\n/* set the shift of the edge from vertex v\n   labelled by character c to integer s in graph g */\nvoid setShift(Graph g, int v, unsigned char c, int s) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c <= g->edgeNumber)\n      g->shift[v*(g->edgeNumber/g->vertexNumber) + c] = s;\n   else\n      error("setShift");\n}\n\n\n/* copies all the characteristics of vertex source\n   to vertex target in graph g */\nvoid copyVertex(Graph g, int target, int source) {\n   if (g != NULL && target < g->vertexNumber &&\n       source < g->vertexNumber) {\n      if (g->target != NULL)\n         memcpy(g->target +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->target +\n                source*(g->edgeNumber/g->vertexNumber),\n                (g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->shift != NULL)\n         memcpy(g->shift +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->shift +\n                source*(g->edgeNumber/g->vertexNumber),\n                g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->terminal != NULL)\n         g->terminal[target] = g->terminal[source];\n      if (g->suffixLink != NULL)\n         g->suffixLink[target] = g->suffixLink[source];\n      if (g->length != NULL)\n         g->length[target] = g->length[source];\n      if (g->position != NULL)\n         g->position[target] = g->position[source];\n   }\n   else\n      error("copyVertex");\n}\n\nvoid preMp(char *x, int m, int mpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = mpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = mpNext[j];\n      mpNext[++i] = ++j;\n   }\n}\n\nvoid buildSuffixAutomaton(char *x, int m, Graph aut) {\n   int i, art, init, last, p, q, r;\n   char c;\n  \n   init = getInitial(aut);\n   art = newVertex(aut);\n   setSuffixLink(aut, init, art);\n   last = init;\n   for (i = 0; i < m; ++i) {\n      c = x[i];\n      p = last;\n      q = newVertex(aut);\n      setLength(aut, q, getLength(aut, p) + 1);\n      setPosition(aut, q, getPosition(aut, p) + 1);\n      while (p != init &&\n             getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, p, c, q);\n         setShift(aut, p, c, getPosition(aut, q) -\n                             getPosition(aut, p) - 1);\n         p = getSuffixLink(aut, p);\n      }\n      if (getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, init, c, q);\n         setShift(aut, init, c,\n                  getPosition(aut, q) -\n                  getPosition(aut, init) - 1);\n         setSuffixLink(aut, q, init);\n      }\n      else\n         if (getLength(aut, p) + 1 ==\n             getLength(aut, getTarget(aut, p, c)))\n            setSuffixLink(aut, q, getTarget(aut, p, c));\n         else {\n            r = newVertex(aut);\n            copyVertex(aut, r, getTarget(aut, p, c));\n            setLength(aut, r, getLength(aut, p) + 1);\n            setSuffixLink(aut, getTarget(aut, p, c), r);\n            setSuffixLink(aut, q, r);\n            while (p != art &&\n                   getLength(aut, getTarget(aut, p, c)) >=\n                   getLength(aut, r)) {\n               setShift(aut, p, c,\n                        getPosition(aut,\n                                    getTarget(aut, p, c)) -\n                        getPosition(aut, p) - 1);\n               setTarget(aut, p, c, r);\n               p = getSuffixLink(aut, p);\n            }\n         }\n      last = q;\n   }\n   setTerminal(aut, last);\n   while (last != init) {\n      last = getSuffixLink(aut, last);\n      setTerminal(aut, last);\n   }\n}\n\nchar *reverse(char *x, int m) {\n   char *xR;\n   int i;\n \n   xR = (char *)malloc((m + 1)*sizeof(char));\n   for (i = 0; i < m; ++i)\n      xR[i] = x[m - 1 - i];\n   xR[m] = \'\\0\';\n   return(xR);\n}\n\nvoid TRF(char *x, int m, char *y, int n) {\n   int period, i, j, shift, u, periodOfU, disp, init,\n       state, mu, mpNext[XSIZE + 1];\n   char *xR;\n   Graph aut;\n  \n   /* Preprocessing */\n   aut = newSuffixAutomaton(2*(m + 2), 2*(m + 2)*ASIZE);\n   xR = reverse(x, m);\n   buildSuffixAutomaton(xR, m, aut);\n   init = getInitial(aut);\n   preMp(x, m, mpNext);\n   period = m - mpNext[m];\n   i = 0;\n   shift = m;\n  \n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = m - 1;\n      state = init;\n      u = m - 1 - shift;\n      periodOfU = (shift != m ?\n                   m - shift - mpNext[m - shift] : 0);\n      shift = m;\n      disp = 0;\n      while (i > u &&\n             getTarget(aut, state, y[i + j]) !=\n             UNDEFINED) {\n         disp += getShift(aut, state, y[i + j]);\n         state = getTarget(aut, state, y[i + j]);\n         if (isTerminal(aut, state))\n            shift = i;\n         --i;\n      }\n      if (i <= u)\n         if (disp == 0) {\n            OUTPUT(j);\n            shift = period;\n         }\n         else {\n            mu = (u + 1)/2;\n            if (periodOfU <= mu) {\n               u -= periodOfU;\n               while (i > u &&\n                      getTarget(aut, state, y[i + j]) !=\n                      UNDEFINED) {\n                  disp += getShift(aut, state, y[i + j]);\n                  state = getTarget(aut, state, y[i + j]);\n                  if (isTerminal(aut, state))\n                     shift = i;\n                  --i;\n               }\n               if (i <= u)\n                  shift = disp;\n            }\n            else {\n               u = u - mu - 1;\n               while (i > u &&\n                      getTarget(aut, state, y[i + j]) !=\n                      UNDEFINED) {\n                  disp += getShift(aut, state, y[i + j]);\n                  state = getTarget(aut, state, y[i + j]);\n                  if (isTerminal(aut, state))\n                     shift = i;\n                  --i;\n               }\n            }\n         }\n      j += shift;\n   }\n}\n'),
	(53, '2013-05-01 09:46:10', '2013-05-01 09:50:25', 51, 3, 'struct _cell{\n  int element; \n  struct _cell *next;\n};\n \ntypedef struct _cell *List;\n   \nstruct _graph {\n    int vertexNumber, \n        edgeNumber, \n        vertexCounter, \n        initial, \n        *terminal, \n        *target, \n        *suffixLink,\n        *length, \n        *position, \n        *shift; \n  };\n  \n  typedef struct _graph *Graph; \n  typedef int boolean;\n   \n#define UNDEFINED -1\n  \n/* returns a new data structure for\n   a graph with v vertices and e edges */\nGraph newGraph(int v, int e) {\n   Graph g;\n\n   g = (Graph)calloc(1, sizeof(struct _graph));\n   if (g == NULL)\n      error("newGraph");\n   g->vertexNumber  = v;\n   g->edgeNumber    = e;\n   g->initial       = 0;\n   g->vertexCounter = 1;\n   return(g);\n}\n\n\n/* returns a new data structure for\n   a automaton with v vertices and e edges */\nGraph newAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newGraph(v, e);\n   aut->target = (int *)calloc(e, sizeof(int));\n   if (aut->target == NULL)\n      error("newAutomaton");\n   aut->terminal = (int *)calloc(v, sizeof(int));\n   if (aut->terminal == NULL)\n      error("newAutomaton");\n   return(aut);\n}\n\n\n/* returns a new data structure for\n   a suffix automaton with v vertices and e edges */\nGraph newSuffixAutomaton(int v, int e) {\n   Graph aut;\n\n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newSuffixAutomaton");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newSuffixAutomaton");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newSuffixAutomaton");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newSuffixAutomaton");\n   return(aut);\n}\n \n \n/* returns a new data structure for\n   a trie with v vertices and e edges */\nGraph newTrie(int v, int e) {\n   Graph aut;\n \n   aut = newAutomaton(v, e);\n   memset(aut->target, UNDEFINED, e*sizeof(int));\n   aut->suffixLink = (int *)calloc(v, sizeof(int));\n   if (aut->suffixLink == NULL)\n      error("newTrie");\n   aut->length = (int *)calloc(v, sizeof(int));\n   if (aut->length == NULL)\n      error("newTrie");\n   aut->position = (int *)calloc(v, sizeof(int));\n   if (aut->position == NULL)\n      error("newTrie");\n   aut->shift = (int *)calloc(e, sizeof(int));\n   if (aut->shift == NULL)\n      error("newTrie");\n   return(aut);\n}\n\n\n/* returns a new vertex for graph g */\nint newVertex(Graph g) {\n   if (g != NULL && g->vertexCounter <= g->vertexNumber)\n      return(g->vertexCounter++);\n   error("newVertex");\n}\n\n\n/* returns the initial vertex of graph g */\nint getInitial(Graph g) {\n   if (g != NULL)\n      return(g->initial);\n   error("getInitial");\n}\n\n\n/* returns true if vertex v is terminal in graph g */\nboolean isTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      return(g->terminal[v]);\n   error("isTerminal");\n}\n\n\n/* set vertex v to be terminal in graph g */\nvoid setTerminal(Graph g, int v) {\n   if (g != NULL && g->terminal != NULL &&\n       v < g->vertexNumber)\n      g->terminal[v] = 1;\n   else\n      error("isTerminal");\n}\n\n\n/* returns the target of edge from vertex v\n   labelled by character c in graph g */\nint getTarget(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->target[v*(g->edgeNumber/g->vertexNumber) +\n                       c]);\n   error("getTarget");\n}\n\n\n/* add the edge from vertex v to vertex t\n   labelled by character c in graph g */\nvoid setTarget(Graph g, int v, unsigned char c, int t) {\n   if (g != NULL && g->target != NULL &&\n       v < g->vertexNumber &&\n       v*c <= g->edgeNumber && t < g->vertexNumber)\n      g->target[v*(g->edgeNumber/g->vertexNumber) + c] = t;\n   else\n      error("setTarget");\n}\n\n\n/* returns the suffix link of vertex v in graph g */\nint getSuffixLink(Graph g, int v) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber)\n      return(g->suffixLink[v]);\n   error("getSuffixLink");\n}\n\n\n/* set the suffix link of vertex v\n   to vertex s in graph g */\nvoid setSuffixLink(Graph g, int v, int s) {\n   if (g != NULL && g->suffixLink != NULL &&\n       v < g->vertexNumber && s < g->vertexNumber)\n      g->suffixLink[v] = s;\n   else\n      error("setSuffixLink");\n}\n\n\n/* returns the length of vertex v in graph g */\nint getLength(Graph g, int v) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      return(g->length[v]);\n   error("getLength");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setLength(Graph g, int v, int ell) {\n   if (g != NULL && g->length != NULL &&\n       v < g->vertexNumber)\n      g->length[v] = ell;\n   else\n      error("setLength");\n}\n\n\n/* returns the position of vertex v in graph g */\nint getPosition(Graph g, int v) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      return(g->position[v]);\n   error("getPosition");\n}\n\n\n/* set the length of vertex v to integer ell in graph g */\nvoid setPosition(Graph g, int v, int p) {\n   if (g != NULL && g->position != NULL &&\n       v < g->vertexNumber)\n      g->position[v] = p;\n   else\n      error("setPosition");\n}\n\n\n/* returns the shift of the edge from vertex v\n   labelled by character c in graph g */\nint getShift(Graph g, int v, unsigned char c) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c < g->edgeNumber)\n      return(g->shift[v*(g->edgeNumber/g->vertexNumber) +\n             c]);\n   error("getShift");\n}\n\n\n/* set the shift of the edge from vertex v\n   labelled by character c to integer s in graph g */\nvoid setShift(Graph g, int v, unsigned char c, int s) {\n   if (g != NULL && g->shift != NULL &&\n       v < g->vertexNumber && v*c <= g->edgeNumber)\n      g->shift[v*(g->edgeNumber/g->vertexNumber) + c] = s;\n   else\n      error("setShift");\n}\n\n\n/* copies all the characteristics of vertex source\n   to vertex target in graph g */\nvoid copyVertex(Graph g, int target, int source) {\n   if (g != NULL && target < g->vertexNumber &&\n       source < g->vertexNumber) {\n      if (g->target != NULL)\n         memcpy(g->target +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->target +\n                source*(g->edgeNumber/g->vertexNumber),\n                (g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->shift != NULL)\n         memcpy(g->shift +\n                target*(g->edgeNumber/g->vertexNumber),\n                g->shift +\n                source*(g->edgeNumber/g->vertexNumber),\n                g->edgeNumber/g->vertexNumber)*\n                sizeof(int));\n      if (g->terminal != NULL)\n         g->terminal[target] = g->terminal[source];\n      if (g->suffixLink != NULL)\n         g->suffixLink[target] = g->suffixLink[source];\n      if (g->length != NULL)\n         g->length[target] = g->length[source];\n      if (g->position != NULL)\n         g->position[target] = g->position[source];\n   }\n   else\n      error("copyVertex");\n}\n\nvoid buildSuffixAutomaton(char *x, int m, Graph aut) {\n   int i, art, init, last, p, q, r;\n   char c;\n  \n   init = getInitial(aut);\n   art = newVertex(aut);\n   setSuffixLink(aut, init, art);\n   last = init;\n   for (i = 0; i < m; ++i) {\n      c = x[i];\n      p = last;\n      q = newVertex(aut);\n      setLength(aut, q, getLength(aut, p) + 1);\n      setPosition(aut, q, getPosition(aut, p) + 1);\n      while (p != init &&\n             getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, p, c, q);\n         setShift(aut, p, c, getPosition(aut, q) -\n                             getPosition(aut, p) - 1);\n         p = getSuffixLink(aut, p);\n      }\n      if (getTarget(aut, p, c) == UNDEFINED) {\n         setTarget(aut, init, c, q);\n         setShift(aut, init, c,\n                  getPosition(aut, q) -\n                  getPosition(aut, init) - 1);\n         setSuffixLink(aut, q, init);\n      }\n      else\n         if (getLength(aut, p) + 1 ==\n             getLength(aut, getTarget(aut, p, c)))\n            setSuffixLink(aut, q, getTarget(aut, p, c));\n         else {\n            r = newVertex(aut);\n            copyVertex(aut, r, getTarget(aut, p, c));\n            setLength(aut, r, getLength(aut, p) + 1);\n            setSuffixLink(aut, getTarget(aut, p, c), r);\n            setSuffixLink(aut, q, r);\n            while (p != art &&\n                   getLength(aut, getTarget(aut, p, c)) >=\n                   getLength(aut, r)) {\n               setShift(aut, p, c,\n                        getPosition(aut,\n                                    getTarget(aut, p, c)) -\n                        getPosition(aut, p) - 1);\n               setTarget(aut, p, c, r);\n               p = getSuffixLink(aut, p);\n            }\n         }\n      last = q;\n   }\n   setTerminal(aut, last);\n   while (last != init) {\n      last = getSuffixLink(aut, last);\n      setTerminal(aut, last);\n   }\n}\n\nint FDM(char *x, int m, char *y, int n) {\n   int j, init, ell, state;\n   Graph aut;\n \n   /* Preprocessing */\n   aut = newSuffixAutomaton(2*(m + 2), 2*(m + 2)*ASIZE);\n   buildSuffixAutomaton(x, m, aut);\n   init = getInitial(aut);\n \n   /* Searching */\n   ell = 0;\n   state = init;\n   for (j = 0; j < n; ++j) {\n      if (getTarget(aut, state, y[j]) != UNDEFINED) {\n         ++ell;\n         state = getTarget(aut, state, y[j]);\n      }\n      else {\n         while (state != init &&\n                getTarget(aut, state, y[j]) == UNDEFINED)\n            state = getSuffixLink(aut, state);\n         if (getTarget(aut, state, y[j]) != UNDEFINED) {\n            ell = getLength(aut, state) + 1;\n            state = getTarget(aut, state, y[j]);\n         }\n         else {\n            ell = 0;\n            state = init;\n         }\n      }\n      if (ell == m)\n         OUTPUT(j - m + 1);\n   }\n}'),
	(55, '2013-05-01 09:53:24', '2013-05-01 09:54:28', 53, 3, 'void BNDM(char *x, int m, char *y, int n) {\n  int B[ASIZE];\n  int i, j, s, d, last;\n  if (m > WORD_SIZE)\n    error("BNDM");\n\n  /* Pre processing */\n  memset(B,0,ASIZE*sizeof(int));\n  s=1;\n  for (i=m-1; i>=0; i--){\n    B[x[i]] |= s;\n    s <<= 1;\n  }\n\n  /* Searching phase */\n  j=0;\n  while (j <= n-m){\n    i=m-1; last=m;\n    d = ~0;\n    while (i>=0 && d!=0) {\n      d &= B[y[j+i]];\n      i--;\n      if (d != 0){\n    if (i >= 0)\n      last = i+1;\n    else\n      OUTPUT(j);\n       }\n       d <<= 1;\n     }\n     j += last;\n   }\n  }'),
	(56, '2013-05-01 09:54:50', '2013-05-01 09:56:52', 54, 3, '#define FALSE      0\n#define TRUE       1\n\nint getTransition(char *x, int p, List L[], char c) {\n   List cell;\n\n   if (p > 0 && x[p - 1] == c)\n      return(p - 1);\n   else {\n      cell = L[p];\n      while (cell != NULL)\n         if (x[cell->element] == c)\n            return(cell->element);\n         else\n            cell = cell->next;\n      return(UNDEFINED);\n   }\n}\n\n\nvoid setTransition(int p, int q, List L[]) {\n   List cell;\n\n   cell = (List)malloc(sizeof(struct _cell));\n   if (cell == NULL)\n      error("BOM/setTransition");\n   cell->element = q;\n   cell->next = L[p];\n   L[p] = cell;\n}\n\n\nvoid oracle(char *x, int m, char T[], List L[]) {\n   int i, p, q;\n   int S[XSIZE + 1];\n   char c;\n\n   S[m] = m + 1;\n   for (i = m; i > 0; --i) {\n      c = x[i - 1];\n      p = S[i];\n      while (p <= m &&\n             (q = getTransition(x, p, L, c)) ==\n             UNDEFINED) {\n         setTransition(p, i - 1, L);\n         p = S[p];\n      }\n      S[i - 1] = (p == m + 1 ? m : q);\n   }\n   p = 0;\n   while (p <= m) {\n      T[p] = TRUE;\n      p = S[p];\n   }\n}\n\n\nvoid BOM(char *x, int m, char *y, int n) {\n   char T[XSIZE + 1];\n   List L[XSIZE + 1];\n   int i, j, p, period, q, shift;\n\n   /* Preprocessing */\n   memset(L, NULL, (m + 1)*sizeof(List));\n   memset(T, FALSE, (m + 1)*sizeof(char));\n   oracle(x, m, T, L);\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = m - 1;\n      p = m;\n      shift = m;\n      while (i + j >= 0 &&\n             (q = getTransition(x, p, L, y[i + j])) !=\n             UNDEFINED) {\n         p = q;\n         if (T[p] == TRUE) {\n            period = shift;\n            shift = i;\n         }\n         --i;\n      }\n      if (i < 0) {\n         OUTPUT(j);\n         shift = period;\n      }\n      j += shift;\n   }\n}'),
	(57, '2013-05-01 09:56:56', '2013-05-01 09:58:13', 55, 3, 'char *x, *y;\nint k, m, n, p, p1, p2, q, q1, q2, s;\n\n\nvoid search() {\n   while (p <= n - m) {\n      while (p + s + q < n && x[s + q] == y[p + s + q])\n         ++q;\n      if (q == m - s && memcmp(x, y + p, s + 1) == 0)\n         OUTPUT(p);\n      if (q == p1 + q1) {\n         p += p1;\n         q -= p1;\n      }\n      else {\n         p += (q/k + 1);\n         q = 0;\n      }\n   }\n}\n\n\nvoid parse() {\n   while (1) {\n      while (x[s + q1] == x[s + p1 + q1])\n         ++q1;\n      while (p1 + q1 >= k*p1) {\n         s += p1;\n         q1 -= p1;\n      }\n      p1 += (q1/k + 1);\n      q1 = 0;\n      if (p1 >= p2)\n         break;\n   }\n   newP1();\n}\n \n\nvoid newP2() {\n   while (x[s + q2] == x[s + p2 + q2] && p2 + q2 < k*p2)\n      ++q2;\n   if (p2 + q2 == k*p2)\n      parse();\n   else\n      if (s + p2 + q2 == m)\n         search();\n      else {\n         if (q2 == p1 + q1) {\n            p2 += p1;\n            q2 -= p1;\n         }\n         else {\n            p2 += (q2/k + 1);\n            q2 = 0;\n         }\n         newP2();\n      }\n}\n \n\nvoid newP1() {\n   while (x[s + q1] == x[s + p1 + q1])\n      ++q1;\n   if (p1 + q1 >= k*p1) {\n      p2 = q1;\n      q2 = 0;\n      newP2();\n   }\n   else {\n      if (s + p1 + q1 == m)\n         search();\n      else {\n         p1 += (q1/k + 1);\n         q1 = 0;\n         newP1();\n      }\n   }\n}\n\n\nvoid GS(char *argX, int argM, char *argY, int argN) {\n   x = argX;\n   m = argM;\n   y = argY;\n   n = argN;\n   k = 4;\n   p = q = s = q1 = p2 = q2 = 0;\n   p1 = 1;\n   newP1();\n}'),
	(58, '2013-05-01 09:58:25', '2013-05-01 10:00:46', 56, 3, '/* Computing of the maximal suffix for <= */\nint maxSuf(char *x, int m, int *p) {\n   int ms, j, k;\n   char a, b;\n\n   ms = -1;\n   j = 0;\n   k = *p = 1;\n   while (j + k < m) {\n      a = x[j + k];\n      b = x[ms + k];\n      if (a < b) {\n         j += k;\n         k = 1;\n         *p = j - ms;\n      }\n      else\n         if (a == b)\n            if (k != *p)\n               ++k;\n            else {\n               j += *p;\n               k = 1;\n            }\n         else { /* a > b */\n            ms = j;\n            j = ms + 1;\n            k = *p = 1;\n         }\n   }\n   return(ms);\n}\n \n/* Computing of the maximal suffix for >= */\nint maxSufTilde(char *x, int m, int *p) {\n   int ms, j, k;\n   char a, b;\n\n   ms = -1;\n   j = 0;\n   k = *p = 1;\n   while (j + k < m) {\n      a = x[j + k];\n      b = x[ms + k];\n      if (a > b) {\n         j += k;\n         k = 1;\n         *p = j - ms;\n      }\n      else\n         if (a == b)\n            if (k != *p)\n               ++k;\n            else {\n               j += *p;\n               k = 1;\n            }\n         else { /* a < b */\n            ms = j;\n            j = ms + 1;\n            k = *p = 1;\n         }\n   }\n   return(ms);\n}\n\n\n/* Two Way string matching algorithm. */\nvoid TW(char *x, int m, char *y, int n) {\n   int i, j, ell, memory, p, per, q;\n\n   /* Preprocessing */\n   i = maxSuf(x, m, &p);\n   j = maxSufTilde(x, m, &q);\n   if (i > j) {\n      ell = i;\n      per = p;\n   }\n   else {\n      ell = j;\n      per = q;\n   }\n\n   /* Searching */\n   if (memcmp(x, x + per, ell + 1) == 0) {\n      j = 0;\n      memory = -1;\n      while (j <= n - m) {\n         i = MAX(ell, memory) + 1;\n         while (i < m && x[i] == y[i + j])\n            ++i;\n         if (i >= m) {\n            i = ell;\n            while (i > memory && x[i] == y[i + j])\n               --i;\n            if (i <= memory)\n               OUTPUT(j);\n            j += per;\n            memory = m - per - 1;\n         }\n         else {\n            j += (i - ell);\n            memory = -1;\n         }\n      }\n   }\n   else {\n      per = MAX(ell + 1, m - ell - 1) + 1;\n      j = 0;\n      while (j <= n - m) {\n         i = ell + 1;\n         while (i < m && x[i] == y[i + j])\n            ++i;\n         if (i >= m) {\n            i = ell;\n            while (i >= 0 && x[i] == y[i + j])\n               --i;\n            if (i < 0)\n               OUTPUT(j);\n            j += per;\n         }\n         else\n            j += (i - ell);\n      }\n   }\n}'),
	(59, '2013-05-01 10:00:50', '2013-05-01 10:04:09', 57, 3, '/* Compute the next maximal suffix. */\nvoid nextMaximalSuffix(char *x, int m,\n                       int *i, int *j, int *k, int *p) {\n   char a, b;\n \n   while (*j + *k < m) {\n      a = x[*i + *k];\n      b = x[*j + *k];\n      if (a == b)\n         if (*k == *p) {\n            (*j) += *p;\n            *k = 1;\n         }\n         else\n            ++(*k);\n      else\n         if (a > b) {\n            (*j) += *k;\n            *k = 1;\n            *p = *j - *i;\n         }\n         else {\n            *i = *j;\n            ++(*j);\n            *k = *p = 1;\n         }\n   }\n}\n \n \n/* String matching on ordered alphabets algorithm. */\nvoid SMOA(char *x, int m, char *y, int n) {\n   int i, ip, j, jp, k, p;\n \n   /* Searching */\n   ip = -1;\n   i = j = jp = 0;\n   k = p = 1;\n   while (j <= n - m) {\n      while (i + j < n && i < m && x[i] == y[i + j])\n         ++i;\n      if (i == 0) {\n         ++j;\n         ip = -1;\n         jp = 0;\n         k = p = 1;\n      }\n      else {\n         if (i >= m)\n            OUTPUT(j);\n         nextMaximalSuffix(y + j, i+1, &ip, &jp, &k, &p);\n         if (ip < 0 ||\n             (ip < p &&\n              memcmp(y + j, y + j + p, ip + 1) == 0)) {\n            j += p;\n            i -= p;\n            if (i < 0)\n               i = 0;\n            if (jp - ip > p)\n               jp -= p;\n            else {\n               ip = -1;\n               jp = 0;\n               k = p = 1;\n            }\n         }\n         else {\n            j += (MAX(ip + 1,\n                      MIN(i - ip - 1, jp + 1)) + 1);\n            i = jp = 0;\n            ip = -1;\n            k = p = 1;\n         }\n      }\n   }\n}\n'),
	(60, '2013-05-01 10:05:31', '2013-05-01 10:12:36', 58, 3, 'void preQsBc(char *x, int m, int qsBc[]) {\n   int i;\n\n   for (i = 0; i < ASIZE; ++i)\n      qsBc[i] = m + 1;\n   for (i = 0; i < m; ++i)\n      qsBc[x[i]] = m - i;\n}\n\ntypedef struct patternScanOrder {\n   int loc;\n   char c;\n} pattern;\n\nint freq[ASIZE];\n\n/* Construct an ordered pattern from a string. */\nvoid orderPattern(char *x, int m, int (*pcmp)(),\n                  pattern *pat) {\n   int i;\n\n   for (i = 0; i <= m; ++i) {\n      pat[i].loc = i;\n      pat[i].c = x[i];\n   }\n   qsort(pat, m, sizeof(pattern), pcmp);\n}\n\n\n/* Optimal Mismatch pattern comparison function. */\nint optimalPcmp(pattern *pat1, pattern *pat2) {\n   float fx;\n\n   fx = freq[pat1->c] - freq[pat2->c];\n   return(fx ? (fx > 0 ? 1 : -1) :\n               (pat2->loc - pat1->loc));\n}\n\n\n/* Find the next leftward matching shift for\n   the first ploc pattern elements after a\n   current shift or lshift. */\nint matchShift(char *x, int m, int ploc,\n               int lshift, pattern *pat) {\n   int i, j;\n\n   for (; lshift < m; ++lshift) {\n      i = ploc;\n      while (--i >= 0) {\n         if ((j = (pat[i].loc - lshift)) < 0)\n            continue;\n         if (pat[i].c != x[j])\n            break;\n      }\n      if (i < 0)\n         break;\n   }\n   return(lshift);\n}\n\n\n/* Constructs the good-suffix shift table\n   from an ordered string. */\nvoid preAdaptedGs(char *x, int m, int adaptedGs[],\n                  pattern *pat) {\n   int lshift, i, ploc;\n\n   adaptedGs[0] = lshift = 1;\n   for (ploc = 1; ploc <= m; ++ploc) {\n      lshift = matchShift(x, m, ploc, lshift, pat);\n      adaptedGs[ploc] = lshift;\n   }\n   for (ploc = 0; ploc <= m; ++ploc) {\n      lshift = adaptedGs[ploc];\n      while (lshift < m) {\n         i = pat[ploc].loc - lshift;\n         if (i < 0 || pat[ploc].c != x[i])\n            break;\n         ++lshift;\n         lshift = matchShift(x, m, ploc, lshift, pat);\n      }\n      adaptedGs[ploc] = lshift;\n   }\n}\n\n\n/* Optimal Mismatch string matching algorithm. */\nvoid OM(char *x, int m, char *y, int n) {\n   int i, j, adaptedGs[XSIZE], qsBc[ASIZE];\n   pattern pat[XSIZE];\n\n   /* Preprocessing */\n   orderPattern(x, m, optimalPcmp, pat);\n   preQsBc(x, m, qsBc);\n   preAdaptedGs(x, m, adaptedGs, pat);\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = 0;\n      while (i < m && pat[i].c == y[j + pat[i].loc])\n         ++i;\n      if (i >= m)\n         OUTPUT(j);\n      j += MAX(adaptedGs[i],qsBc[y[j + m]]);\n   }\n}'),
	(62, '2013-05-01 10:16:14', '2013-05-01 10:18:23', 60, 3, 'void preQsBc(char *x, int m, int qsBc[]) {\n   int i;\n\n   for (i = 0; i < ASIZE; ++i)\n      qsBc[i] = m + 1;\n   for (i = 0; i < m; ++i)\n      qsBc[x[i]] = m - i;\n}\n\n/* Construct an ordered pattern from a string. */\nvoid orderPattern(char *x, int m, int (*pcmp)(),\n                  pattern *pat) {\n   int i;\n\n   for (i = 0; i <= m; ++i) {\n      pat[i].loc = i;\n      pat[i].c = x[i];\n   }\n   qsort(pat, m, sizeof(pattern), pcmp);\n}\n\n/* Find the next leftward matching shift for\n   the first ploc pattern elements after a\n   current shift or lshift. */\nint matchShift(char *x, int m, int ploc,\n               int lshift, pattern *pat) {\n   int i, j;\n\n   for (; lshift < m; ++lshift) {\n      i = ploc;\n      while (--i >= 0) {\n         if ((j = (pat[i].loc - lshift)) < 0)\n            continue;\n         if (pat[i].c != x[j])\n            break;\n      }\n      if (i < 0)\n         break;\n   }\n   return(lshift);\n}\n\n/* Constructs the good-suffix shift table\n   from an ordered string. */\nvoid preAdaptedGs(char *x, int m, int adaptedGs[],\n                  pattern *pat) {\n   int lshift, i, ploc;\n\n   adaptedGs[0] = lshift = 1;\n   for (ploc = 1; ploc <= m; ++ploc) {\n      lshift = matchShift(x, m, ploc, lshift, pat);\n      adaptedGs[ploc] = lshift;\n   }\n   for (ploc = 0; ploc <= m; ++ploc) {\n      lshift = adaptedGs[ploc];\n      while (lshift < m) {\n         i = pat[ploc].loc - lshift;\n         if (i < 0 || pat[ploc].c != x[i])\n            break;\n         ++lshift;\n         lshift = matchShift(x, m, ploc, lshift, pat);\n      }\n      adaptedGs[ploc] = lshift;\n   }\n}\n\ntypedef struct patternScanOrder {\n   int loc;\n   char c;\n} pattern;\n\nint minShift[XSIZE];\n\n/* Computation of the MinShift table values. */\nvoid computeMinShift(char *x, int m) {\n   int i, j;\n\n   for (i = 0; i < m; ++i) {\n      for (j = i - 1; j >= 0; --j)\n          if (x[i] == x[j])\n             break;\n      minShift[i] = i - j;\n   }\n}\n\n\n/* Maximal Shift pattern comparison function. */\nint maxShiftPcmp(pattern *pat1, pattern *pat2) {\n   int dsh;\n\n   dsh = minShift[pat2->loc] - minShift[pat1->loc];\n   return(dsh ? dsh : (pat2->loc - pat1->loc));\n}\n\n\n/* Maximal Shift string matching algorithm. */\nvoid MS(char *x, int m, char *y, int n) {\n   int i, j, qsBc[ASIZE], adaptedGs[XSIZE];\n   pattern pat[XSIZE];\n\n   /* Preprocessing */\n   computeMinShift(x ,m);\n   orderPattern(x, m, maxShiftPcmp, pat);\n   preQsBc(x, m, qsBc);\n   preAdaptedGs(x, m, adaptedGs, pat);\n\n   /* Searching */\n   j = 0;\n   while (j <= n - m) {\n      i = 0;\n      while (i < m && pat[i].c == y[j + pat[i].loc])\n         ++i;\n      if (i >= m)\n         OUTPUT(j);\n      j += MAX(adaptedGs[i], qsBc[y[j + m]]);\n   }\n}'),
	(63, '2013-05-01 10:18:43', '2013-05-01 10:20:55', 61, 3, 'void SKIP(char *x, int m, char *y, int n) {\n   int i, j;\n   List ptr, z[ASIZE];\n\n   /* Preprocessing */\n   memset(z, NULL, ASIZE*sizeof(List));\n   for (i = 0; i < m; ++i) {\n      ptr = (List)malloc(sizeof(struct _cell));\n      if (ptr == NULL)\n         error("SKIP");\n      ptr->element = i;\n      ptr->next = z[x[i]];\n      z[x[i]] = ptr;\n   }\n  \n   /* Searching */\n   for (j = m - 1; j < n; j += m)\n      for (ptr = z[y[j]]; ptr != NULL; ptr = ptr->next)\n         if (memcmp(x, y + j - ptr->element, m) == 0) {\n            if (j - ptr->element <= n - m)\n               OUTPUT(j - ptr->element);\n         }\n         else\n            break;\n}\n\n/* In practice the test j - ptr->element <= n - m can be omitted and the algorithm becomes : */\nvoid SKIP2(char *x, int m, char *y, int n) {\n   int i, j;\n   List ptr, z[ASIZE];\n\n   /* Preprocessing */\n   memset(z, NULL, ASIZE*sizeof(List));\n   for (i = 0; i < m; ++i) {\n      ptr = (List)malloc(sizeof(struct _cell));\n      if (ptr == NULL)\n         error("SKIP");\n      ptr->element = i;\n      ptr->next = z[x[i]];\n      z[x[i]] = ptr;\n   }\n  \n   /* Searching */\n   for (j = m - 1; j < n; j += m)\n      for (ptr = z[y[j]]; ptr != NULL; ptr = ptr->next)\n         if (memcmp(x, y + j - ptr->element, m) == 0)\n            OUTPUT(j - ptr->element);\n}\n\n\n\n\n\n\n\n\n\n'),
	(64, '2013-05-01 10:20:58', '2013-05-01 10:23:15', 62, 3, 'void preMp(char *x, int m, int mpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = mpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = mpNext[j];\n      mpNext[++i] = ++j;\n   }\n}\n\nvoid preKmp(char *x, int m, int kmpNext[]) {\n   int i, j;\n\n   i = 0;\n   j = kmpNext[0] = -1;\n   while (i < m) {\n      while (j > -1 && x[i] != x[j])\n         j = kmpNext[j];\n      i++;\n      j++;\n      if (x[i] == x[j])\n         kmpNext[i] = kmpNext[j];\n      else\n         kmpNext[i] = j;\n   }\n}\n\nint attempt(char *y, char *x, int m, int start, int wall) {\n   int k;\n\n   k = wall - start;\n   while (k < m && x[k] == y[k + start])\n      ++k;\n   return(k);\n}\n\n\nvoid KMPSKIP(char *x, int m, char *y, int n) {\n   int i, j, k, kmpStart, per, start, wall;\n   int kmpNext[XSIZE], list[XSIZE], mpNext[XSIZE],\n       z[ASIZE];\n\n   /* Preprocessing */\n   preMp(x, m, mpNext);\n   preKmp(x, m, kmpNext);\n   memset(z, -1, ASIZE*sizeof(int));\n   memset(list, -1, m*sizeof(int));\n   z[x[0]] = 0;\n   for (i = 1; i < m; ++i) {\n      list[i] = z[x[i]];\n      z[x[i]] = i;\n   }\n\n   /* Searching */\n   wall = 0;\n   per = m - kmpNext[m];\n   i = j = -1;\n   do {\n      j += m;\n   } while (j < n && z[y[j]] < 0);\n   if (j >= n)\n     return;\n   i = z[y[j]];\n   start = j - i;\n   while (start <= n - m) {\n      if (start > wall)\n         wall = start;\n      k = attempt(y, x, m, start, wall);\n      wall = start + k;\n      if (k == m) {\n         OUTPUT(start);\n         i -= per;\n      }\n      else\n         i = list[i];\n      if (i < 0) {\n         do {\n            j += m;\n         } while (j < n && z[y[j]] < 0);\n         if (j >= n)\n            return;\n         i = z[y[j]];\n      }\n      kmpStart = start + k - kmpNext[k];\n      k = kmpNext[k];\n      start = j - i;\n      while (start < kmpStart ||\n             (kmpStart < start && start < wall)) {\n         if (start < kmpStart) {\n            i = list[i];\n            if (i < 0) {\n               do {\n                  j += m;\n               } while (j < n && z[y[j]] < 0);\n               if (j >= n)\n                  return;\n               i = z[y[j]];\n            }\n            start = j - i;\n         }\n         else {\n            kmpStart += (k - mpNext[k]);\n            k = mpNext[k];\n         }\n      }\n   }\n}'),
	(65, '2013-05-01 10:23:20', '2013-05-01 10:24:39', 63, 3, 'List *z;\n \n#define getZ(i) z[(i)]\n \nvoid setZ(int node, int i) {\n   List cell;\n \n   cell = (List)malloc(sizeof(struct _cell));\n   if (cell == NULL)\n      error("ALPHASKIP/setZ");\n   cell->element = i;\n   cell->next = z[node];\n   z[node] = cell;\n}\n \n \n/* Create the transition labelled by the\n    character c from node node.\n   Maintain the suffix links accordingly. */\nint addNode(Graph trie, int art, int node, char c) {\n   int childNode, suffixNode, suffixChildNode;\n \n   childNode = newVertex(trie);\n   setTarget(trie, node, c, childNode);\n   suffixNode = getSuffixLink(trie, node);\n   if (suffixNode == art)\n      setSuffixLink(trie, childNode, node);\n   else {\n      suffixChildNode = getTarget(trie, suffixNode, c);\n      if (suffixChildNode == UNDEFINED)\n         suffixChildNode = addNode(trie, art,\n                                   suffixNode, c);\n      setSuffixLink(trie, childNode, suffixChildNode);\n   }\n   return(childNode);\n}\n\n\nvoid ALPHASKIP(char *x, int m, char *y, int n, int a) {\n   int b, i, j, k, logM, temp, shift, size, pos;\n   int art, childNode, node, root, lastNode;\n   List current;\n   Graph trie;\n \n   logM = 0;\n   temp = m;\n   while (temp > a) {\n      ++logM;\n      temp /= a;\n   }\n   if (logM == 0) logM = 1;\n   \n \n   /* Preprocessing */\n   size = 2 + (2*m - logM + 1)*logM;\n   trie = newTrie(size, size*ASIZE);\n   z = (List *)calloc(size, sizeof(List));\n   if (z == NULL)\n      error("ALPHASKIP");\n \n   root = getInitial(trie);\n   art = newVertex(trie);\n   setSuffixLink(trie, root, art);\n   node = newVertex(trie);\n   setTarget(trie, root, x[0], node);\n   setSuffixLink(trie, node, root);\n   for (i = 1; i < logM; ++i)\n      node = addNode(trie, art, node, x[i]);\n   pos = 0;\n   setZ(node, pos);\n   pos++;\n   for (i = logM; i < m - 1; ++i) {\n      node = getSuffixLink(trie, node);\n      childNode = getTarget(trie, node, x[i]);\n      if (childNode == UNDEFINED)\n         node = addNode(trie, art, node, x[i]);\n      else\n         node = childNode;\n      setZ(node, pos);\n      pos++;\n   }\n   node = getSuffixLink(trie, node);\n   childNode = getTarget(trie, node, x[i]);\n   if (childNode == UNDEFINED) {\n      lastNode = newVertex(trie);\n      setTarget(trie, node, x[m - 1], lastNode);\n      node = lastNode;\n   }\n   else\n      node = childNode;\n   setZ(node, pos);\n \n   /* Searching */\n   shift = m - logM + 1;\n   for (j = m + 1 - logM; j < n - logM; j += shift) {\n      node = root;\n      for (k = 0; node != UNDEFINED && k < logM; ++k)\n         node = getTarget(trie, node, y[j + k]);\n      if (node != UNDEFINED)\n         for (current = getZ(node);\n              current != NULL;\n              current = current->next) {\n            b = j - current->element;\n            if (x[0] == y[b] &&\n                memcmp(x + 1, y + b + 1, m - 1) == 0)\n               OUTPUT(b);\n         }\n   }\n   free(z);\n}');
/*!40000 ALTER TABLE `main_implementationmodel` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_languagemodel
CREATE TABLE IF NOT EXISTS `main_languagemodel` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) COLLATE utf8_unicode_ci NOT NULL,
  `is_dynamic` tinyint(1) NOT NULL,
  `family` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `lexer` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  `description` longtext COLLATE utf8_unicode_ci NOT NULL,
  `example_code` longtext COLLATE utf8_unicode_ci NOT NULL,
  `date_added` datetime NOT NULL,
  `date_modified` datetime NOT NULL,
  `index` int(10) NOT NULL,
  `slug` char(50) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_languagemodel: ~49 rows (approximately)
/*!40000 ALTER TABLE `main_languagemodel` DISABLE KEYS */;
INSERT INTO `main_languagemodel` (`id`, `name`, `is_dynamic`, `family`, `lexer`, `description`, `example_code`, `date_added`, `date_modified`, `index`, `slug`) VALUES
	(2, 'Python', 1, 'python', 'text/x-python', '', 'print "Hello, world!"', '2013-04-27 17:19:48', '2013-04-30 09:02:59', 100, 'python'),
	(3, 'C', 0, 'clike', 'text/x-csrc', '', '', '2013-04-27 17:20:10', '2013-04-27 17:20:10', 50, 'c'),
	(4, 'C++', 0, 'clike', 'text/x-c++src', '', '', '2013-04-27 17:20:25', '2013-04-27 17:20:25', 100, 'cpp'),
	(5, 'Java', 0, 'clike', 'text/x-java', '', '', '2013-04-27 17:20:44', '2013-04-27 17:20:44', 100, 'java'),
	(6, 'C#', 0, 'clike', 'text/x-csharp', '', 'using System;\r\n \r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        Console.WriteLine("Hello World!"); \r\n    }\r\n}\r\n', '2013-04-27 17:20:56', '2013-04-30 09:02:41', 100, 'csharp'),
	(7, 'Clojure', 0, 'clojure', 'text/x-clojure', '', '', '2013-04-27 17:21:12', '2013-04-27 17:21:12', 50, 'clojure'),
	(8, 'CoffeeScript', 0, 'coffeescript', 'text/x-coffeescript', '', '', '2013-04-27 17:21:30', '2013-04-27 17:21:30', 10, 'coffeescript'),
	(9, 'Lisp', 0, 'commonlisp', 'text/x-common-lisp', '', '', '2013-04-27 17:22:05', '2013-04-27 17:22:05', 50, 'lisp'),
	(10, 'CSS', 0, 'css', 'text/css', '', '', '2013-04-27 17:22:26', '2013-04-27 17:22:26', -1, 'css'),
	(11, 'D', 0, 'd', 'text/x-d', '', '', '2013-04-27 17:22:47', '2013-04-27 17:22:47', 50, 'd'),
	(12, 'Diff', 0, 'diff', 'text/x-diff', '', '', '2013-04-27 17:23:00', '2013-04-27 17:23:00', -1, 'diff'),
	(13, 'ECL', 0, 'ecl', 'text/x-ecl', '', '', '2013-04-27 17:23:13', '2013-04-27 17:23:13', -1, 'ecl'),
	(14, 'Z80', 0, 'z80', 'text/x-z80', '', '', '2013-04-27 17:25:09', '2013-04-27 17:25:09', -1, 'z80'),
	(15, 'YAML', 0, 'yaml', 'text/x-yaml', '', '', '2013-04-27 17:25:22', '2013-04-27 17:25:22', -1, 'yaml'),
	(16, 'XQuery', 0, 'xquery', 'application/xquery', '', '', '2013-04-27 17:25:41', '2013-04-27 17:25:41', -1, 'xquery'),
	(17, 'XML', 0, 'xml', 'application/xml', '', '<xml>\r\n    Hello, world!\r\n</xml>', '2013-04-27 17:25:58', '2013-04-30 09:04:28', -1, 'xml'),
	(18, 'Velocity', 0, 'velocity', 'text/velocity', '', '', '2013-04-27 17:26:11', '2013-04-27 17:26:11', -1, 'velocity'),
	(19, 'VBScript', 0, 'vbscript', 'text/vbscript', '', '', '2013-04-27 17:26:23', '2013-04-27 17:26:23', 10, 'vbscript'),
	(20, 'VB.NET', 0, 'vb', 'text/x-vb', '', '', '2013-04-27 17:27:06', '2013-04-27 17:27:06', -1, 'vb.net'),
	(21, 'Tcl', 0, 'tcl', 'text/x-tcl', '', '', '2013-04-27 17:27:19', '2013-04-27 17:27:19', -1, 'tcl'),
	(23, 'SPARQL', 0, 'sparql', 'application/x-sparql-query', '', '', '2013-04-27 17:28:36', '2013-04-27 17:28:36', -1, 'sparql'),
	(24, 'SQL', 0, 'sql', 'text/x-sql', '', '', '2013-04-27 17:28:54', '2013-04-27 17:28:54', -1, 'sql'),
	(25, 'Smarty', 0, 'smarty', 'text/x-smarty', '', '', '2013-04-27 17:29:07', '2013-04-27 17:29:07', -1, 'smarty'),
	(26, 'Smalltalk', 0, 'smalltalk', 'text/x-stsrc', '', '', '2013-04-27 17:29:24', '2013-04-27 17:29:24', 10, 'smalltalk'),
	(27, 'Shell', 0, 'shell', 'text/x-sh', '', '', '2013-04-27 17:29:36', '2013-04-27 17:29:36', 10, 'shell'),
	(28, 'Scheme', 0, 'scheme', 'text/x-scheme', '', '', '2013-04-27 17:29:52', '2013-04-27 17:29:52', 10, 'scheme'),
	(29, 'Sass', 0, 'sass', 'text/x-sass', '', '', '2013-04-27 17:30:38', '2013-04-27 17:30:38', -1, 'sass'),
	(30, 'Rust', 0, 'rust', 'text/x-rustsrc', '', '', '2013-04-27 17:30:49', '2013-04-27 17:30:49', -1, 'rust'),
	(31, 'Ruby', 1, 'ruby', 'text/x-ruby', '', '', '2013-04-27 17:31:00', '2013-04-27 17:31:00', 100, 'ruby'),
	(32, 'reStructuredText', 0, 'rst', 'text/x-rst', '', '', '2013-04-27 17:33:27', '2013-04-27 17:33:27', -1, 'restructuredtext'),
	(33, 'R', 0, 'r', 'text/x-rsrc', '', '', '2013-04-27 17:33:38', '2013-04-27 17:33:38', 10, 'r'),
	(34, 'Properties files', 0, 'properties', 'text/x-properties', '', '', '2013-04-27 17:34:31', '2013-04-27 17:34:31', -1, 'properties files'),
	(35, 'PHP', 1, 'php', 'application/x-httpd-php', '', '<?php\r\n    echo "Hello, world!";\r\n?>', '2013-04-27 17:34:58', '2013-04-30 09:03:25', 100, 'php'),
	(36, 'GFM', 0, 'gfm', 'gfm', '', '', '2013-04-27 17:35:13', '2013-04-27 17:35:13', -1, 'gfm'),
	(37, 'Perl', 1, 'perl', 'text/x-perl', '', '', '2013-04-27 17:36:44', '2013-04-27 17:36:44', 50, 'perl'),
	(38, 'Pascal', 0, 'pascal', 'text/x-pascal', '', '', '2013-04-27 17:36:57', '2013-04-27 17:36:57', 50, 'pascal'),
	(39, 'OCaml', 0, 'ocaml', 'text/x-ocaml', '', '', '2013-04-27 17:37:13', '2013-04-27 17:37:13', 10, 'ocaml'),
	(40, 'NTriples', 0, 'ntriples', 'text/n-triples', '', '', '2013-04-27 17:37:39', '2013-04-27 17:37:39', -1, 'ntriples'),
	(41, 'Markdown', 0, 'markdown', 'text/x-markdown', '', '', '2013-04-27 17:37:52', '2013-04-27 17:37:52', -1, 'markdown'),
	(42, 'Lua', 1, 'lua', 'text/x-lua', '', '', '2013-04-27 17:38:03', '2013-04-27 17:38:03', 10, 'lua'),
	(43, 'Less', 0, 'less', 'text/x-less', '', '', '2013-04-27 17:38:15', '2013-04-27 17:38:15', -1, 'less'),
	(44, 'JavaScript', 1, 'javascript', 'text/javascript', '', 'alert("Hello, world!");', '2013-04-27 17:38:52', '2013-04-30 09:03:45', 100, 'javascript'),
	(45, 'HTTP', 0, 'http', 'message/http', '', '', '2013-04-27 17:39:13', '2013-04-27 17:39:13', -1, 'http'),
	(46, 'HTML', 0, 'html', 'text/html', '', '<span>Hello world</span>', '2013-04-27 17:39:24', '2013-04-30 09:04:08', -1, 'html'),
	(47, 'Haxe', 0, 'haxe', 'text/x-haxe', '', '', '2013-04-27 17:39:35', '2013-04-27 17:39:35', -1, 'haxe'),
	(48, 'Haskell', 0, 'haskell', 'text/x-haskell', '', '', '2013-04-27 17:39:56', '2013-04-27 17:39:56', 50, 'haskell'),
	(49, 'Groovy', 0, 'groovy', 'text/x-groovy', '', '', '2013-04-27 17:40:09', '2013-04-27 17:40:09', -1, 'groovy'),
	(50, 'Go', 1, 'go', 'text/x-go', '', '', '2013-04-27 17:40:20', '2013-04-27 17:40:20', 50, 'go'),
	(51, 'Erlang', 0, 'erlang', 'text/x-erlang', '', '', '2013-04-27 17:40:32', '2013-04-27 17:40:32', 10, 'erlang');
/*!40000 ALTER TABLE `main_languagemodel` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_tagmodel
CREATE TABLE IF NOT EXISTS `main_tagmodel` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `date_added` datetime NOT NULL,
  `date_modified` datetime NOT NULL,
  `name` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_tagmodel: ~8 rows (approximately)
/*!40000 ALTER TABLE `main_tagmodel` DISABLE KEYS */;
INSERT INTO `main_tagmodel` (`id`, `date_added`, `date_modified`, `name`) VALUES
	(2, '2013-04-27 18:37:18', '2013-04-27 18:37:18', 'String'),
	(3, '2013-04-27 18:37:18', '2013-04-27 18:37:18', 'Substring'),
	(4, '2013-04-27 18:37:18', '2013-04-27 18:37:18', 'Search'),
	(5, '2013-04-27 18:37:18', '2013-04-27 18:37:18', 'Machine'),
	(6, '2013-04-27 18:39:18', '2013-04-27 18:39:19', 'State machine'),
	(12, '2013-04-30 09:50:42', '2013-04-30 09:50:42', 'Example'),
	(13, '2013-04-30 10:04:18', '2013-04-30 10:04:19', 'Sort'),
	(14, '2013-04-30 10:40:16', '2013-04-30 10:40:16', '');
/*!40000 ALTER TABLE `main_tagmodel` ENABLE KEYS */;


-- Dumping structure for table algo.pw.main_userprofile
CREATE TABLE IF NOT EXISTS `main_userprofile` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `key` varchar(256) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`),
  CONSTRAINT `user_id_refs_id_31159d2a` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- Dumping data for table algo.pw.main_userprofile: ~1 rows (approximately)
/*!40000 ALTER TABLE `main_userprofile` DISABLE KEYS */;
INSERT INTO `main_userprofile` (`id`, `user_id`, `key`) VALUES
	(1, 1, ',&7JEQpkrpr"9Ikqvcq@c/zSBj04/_0OX@dyyAp	o+)0;zKn\nd3:Y:{GR6`RJ\\"');
/*!40000 ALTER TABLE `main_userprofile` ENABLE KEYS */;
/*!40014 SET FOREIGN_KEY_CHECKS=1 */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
